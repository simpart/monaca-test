/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("(async () => {\n  /* require */\n  __webpack_require__(/*! mofron */ \"./node_modules/mofron/index-exposed.js\");\n  const Frame = __webpack_require__(/*! mofron-comp-frame */ \"./node_modules/mofron-comp-frame/index.js\");\n  const Click = __webpack_require__(/*! mofron-event-click */ \"./node_modules/mofron-event-click/index.js\");\n  const Tap = __webpack_require__(/*! mofron-event-tap */ \"./node_modules/mofron-event-tap/index.js\");\n  const comutl = mofron.util.common;\n  const cmputl = mofron.util.component;\n  try {\n    /* script (extern) */\n\n    /* script (init) */\n    let AUDIO = new Audio('https://dr-train.s3.ap-northeast-1.amazonaws.com/voice/sobu_line.mp3');\n    let event_test = () => {\n      AUDIO.play();\n    };\n\n    /* template */\n\n    /* component */\n    let cmp0 = new Frame();\n    let root_cmp = new mofron.class.Component();\n    root_cmp.child([cmp0]);\n    cmp0.config({\n      event: new Tap(event_test)\n    });\n\n    /* script (before) */\n\n    /* start visible */\n    mofron.root.push(root_cmp);\n    root_cmp.visible(true, () => {\n      try {\n\n        /* script (after) */\n      } catch (e) {\n        console.error(e.stack);\n      }\n    });\n  } catch (e) {\n    console.error(e.stack);\n  }\n})();\n\n//# sourceURL=webpack:///./js/index.js?");

/***/ }),

/***/ "./node_modules/mofron/index-exposed.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/index-exposed.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ \"./node_modules/mofron/index.js\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../expose-loader/dist/runtime/getGlobalThis.js */ \"./node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nvar ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___ = ___EXPOSE_LOADER_IMPORT___.mofron;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"_mofron\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"_mofron\"] = ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___;else throw new Error('[exposes-loader] The \"_mofron\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option');\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n//# sourceURL=webpack:///./node_modules/mofron/index-exposed.js?");

/***/ }),

/***/ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js":
/*!******************************************************************!*\
  !*** ./node_modules/expose-loader/dist/runtime/getGlobalThis.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// eslint-disable-next-line func-names\nmodule.exports = function () {\n  if (typeof globalThis === \"object\") {\n    return globalThis;\n  }\n  var g;\n  try {\n    // This works if eval is allowed (see CSP)\n    // eslint-disable-next-line no-new-func\n    g = this || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") {\n      return window;\n    } // This works if the self reference is available\n\n    if (typeof self === \"object\") {\n      return self;\n    } // This works if the global reference is available\n\n    if (typeof __webpack_require__.g !== \"undefined\") {\n      return __webpack_require__.g;\n    }\n  }\n  return g;\n}();\n\n//# sourceURL=webpack:///./node_modules/expose-loader/dist/runtime/getGlobalThis.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-frame/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-frame/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   mofron-comp-frame/index.js\n * @brief  frame component for mofron\n * @feature default size is 1rem Ã— 1rem\n *          frame size is includes border size\n * @license MIT\n */\nconst Radius = __webpack_require__(/*! mofron-effect-radius */ \"./node_modules/mofron-effect-radius/index.js\");\nconst Shadow = __webpack_require__(/*! mofron-effect-shadow */ \"./node_modules/mofron-effect-shadow/index.js\");\nconst Border = __webpack_require__(/*! mofron-effect-border */ \"./node_modules/mofron-effect-border/index.js\");\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * initialize frame component\n   * \n   * @param (mixed) width parameter\n   *                key-value: component option\n   * @param (string (size)) height parameter\n   * @short width,height\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname(\"Frame\");\n      this.shortForm(\"width\", \"height\");\n\n      /* set config */\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n  initDomConts() {\n    try {\n      super.initDomConts();\n      let pvt = {\n        private: true\n      };\n      /* configure border style */\n      this.effect([new Border({\n        color: [190, 190, 190],\n        tag: \"Frame\"\n      }), new Radius(\"0rem\"), new Shadow(\"0rem\")], pvt);\n      this.childDom().style().listener(\"border-width\", (p1, p2, p3) => {\n        try {\n          let o_bdr = comutl.sizesum(p2[\"border-width\"], p2[\"border-width\"]);\n          p3.size(comutl.sizesum(cmputl.size(p3, \"width\"), o_bdr), comutl.sizesum(cmputl.size(p3, \"height\"), o_bdr));\n        } catch (e) {}\n      }, this);\n      this.width(\"1rem\", pvt);\n      this.height(\"1rem\", pvt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * background color\n   * \n   * @param (mixed (color)) string: background color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (string) background color\n   * @type parameter\n   */\n  mainColor(prm, opt) {\n    try {\n      return cmputl.color(this, \"background\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * border color\n   * \n   * @param (mixed (color)) string: border color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @return (mixed (color)) border color\n   * @type parameter\n   */\n  accentColor(prm, opt) {\n    try {\n      this.effect({\n        modname: \"Shadow\"\n      }).color(prm);\n      return this.effect({\n        modname: \"Border\"\n      }).color(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * radius effect\n   *\n   * @param (string (size)) radius effect value\n   * @return (string (size)) radius effect value\n   * @type parameter\n   */\n  radius(prm) {\n    try {\n      return this.effect({\n        modname: \"Radius\"\n      }).value(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * shadow effect\n   *\n   * @param (string (size)) shadow value\n   * @return (string (size)) shadow value\n   * @type parameter\n   */\n  shadow(prm) {\n    try {\n      return this.effect({\n        modname: \"Shadow\"\n      }).blur(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * border width setter\n   * \n   * @param (string(size)) top border width\n   * @param (string(size)) right border width\n   * @param (string(size)) bottom border width\n   * @param (string(size)) left border width\n   * @type parameter\n   */\n  borderWidth(top, right, bottom, left) {\n    try {\n      if (1 === arguments.length) {\n        this.effect({\n          modname: \"Border\"\n        }).width(top);\n      } else {\n        this.style({\n          \"border-top-width\": top,\n          \"border-right-width\": right,\n          \"border-bottom-width\": bottom,\n          \"border-left-width\": left\n        }, {\n          locked: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * frame width\n   * \n   * @param (string (size)) frame width\n   * @param (key-value) style option\n   * @return (string (size)) frame width\n   * @type parameter\n   */\n  width(prm, opt) {\n    try {\n      return this.frmsiz(\"width\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * frame height\n   * \n   * @param (string (size)) frame height\n   * @param (key-value) style option\n   * @return (string (size)) frame height\n   * @type parameter\n   */\n  height(prm, opt) {\n    try {\n      return this.frmsiz(\"height\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set frame size\n   * \n   * @param (string) size target (width,height)\n   * @type private\n   */\n  frmsiz(tgt, val, opt) {\n    try {\n      if (\"width\" !== tgt && \"height\" !== tgt) {\n        throw new Error(\"invalid parameter\");\n      }\n      let bdr_siz = this.effect({\n        name: \"Border\",\n        tag: \"Frame\"\n      }).width();\n      bdr_siz = comutl.sizesum(bdr_siz, bdr_siz);\n      if (undefined === val) {\n        /* getter */\n        return comutl.sizesum(super[tgt](), bdr_siz);\n      }\n      /* setter */\n      super[tgt](comutl.sizesum(val, null === bdr_siz ? null : \"-\" + bdr_siz));\n    } catch (e) {\n      return super[tgt](val);\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-frame/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-border/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-border/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-border/index.js\n * @brief border effect for mofron\n *        set border style to target component\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   * \n   * @param (mixed) width parameter\n   *                key-value: effect config\n   * @param (mixed) color parameter\n   * @short width,color\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Border');\n      this.shortForm('width', 'color');\n      this.transition([\"border-width\", \"border-top-width\", \"border-bottom-width\", \"border-left-width\", \"border-right-width\", \"border-top-left-width\", \"border-top-right-width\", \"border-bottom-left-width\", \"border-bottom-right-width\", \"border-color\", \"border-top-color\", \"border-bottom-color\", \"border-left-color\", \"border-right-color\", \"border-top-left-color\", \"border-top-right-color\", \"border-bottom-left-color\", \"border-bottom-right-color\"]);\n\n      /* init config */\n      this.confmng().add('width', {\n        type: 'size',\n        init: \"0.01rem\"\n      });\n      this.confmng().add('style', {\n        type: 'string',\n        init: 'solid',\n        select: ['none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted']\n      });\n      this.confmng().add('position', {\n        type: 'string',\n        init: 'all',\n        select: ['all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right']\n      });\n      this.confmng().add('color', {\n        type: 'color',\n        init: [90, 90, 90]\n      });\n\n      /* set config */\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * effect config\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n  contents(cmp) {\n    try {\n      let set_style = {};\n      let pos = 'all' === this.position() ? 'border-' : 'border-' + this.position() + '-';\n      set_style[pos + 'width'] = this.width().toString();\n      set_style[pos + 'style'] = this.style();\n      set_style[pos + 'color'] = this.color().toString();\n      cmp.style(set_style);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * border width\n   * \n   * @param (string) css value of border width\n   * @return (string) css value of border width\n   * @type parameter\n   */\n  width(prm) {\n    try {\n      return this.confmng('width', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * setter/getter border style\n   *\n   * @param (string) css value of border style (default is 'solid')\n   *                 ('none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted')\n   * @return (string) css value of border style\n   * @type parameter\n   */\n  style(prm) {\n    try {\n      return this.confmng('style', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * border position\n   * \n   * @param (string) border target position (default is 'all')\n   *                 ('all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right')\n   * @return (string) css value of border type\n   * @type parameter\n   */\n  position(prm) {\n    try {\n      return this.confmng('position', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * border color\n   * \n   * @param (mixed (color)) string: color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @return (mixed (color)) border color\n   * @type parameter\n   */\n  color(prm) {\n    try {\n      return this.confmng('color', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-border/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-radius/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-radius/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-radius/index.js\n * @brief radius effect for mofron\n *        this effect makes the components of outside rounded style\n * @license MIT\n */\n\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize radius effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @short value\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('Radius');\n      this.shortForm('value');\n\n      /* init config */\n      this.confmng().add(\"value\", {\n        type: \"size\",\n        init: \"0.5rem\"\n      });\n      this.confmng().add(\"position\", {\n        list: true,\n        select: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n      });\n      this.transition([\"border-radius\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-bottom-left-radius\", \"border-bottom-right-radius\"]);\n\n      /* set config */\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * radius size\n   *\n   * @param (string (size)) radius size\n   * @return (string (size)) radius size\n   * @type parameter\n   */\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * radius target position\n   * each position will be targeted if nothing is set \n   * \n   * @param (mixed) array: position list\n   *                string: target position (\"top-left\",\"top-right\",\"bottom-left\",\"bottom-right\")\n   * @return (array) position list\n   * @type parameter\n   */\n  position(prm) {\n    try {\n      return this.confmng('position', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * effect contents\n   * \n   * @param (component) target component\n   * @type private\n   */\n  contents(cmp) {\n    try {\n      let pos = this.position();\n      let val = this.value().toString();\n      if (0 === pos.length) {\n        cmp.style({\n          'border-radius': val\n        }, {\n          bpref: true\n        });\n      } else {\n        let set_sty = {};\n        for (let tidx in pos) {\n          set_sty['border-' + pos[tidx] + '-radius'] = val;\n        }\n        cmp.style(set_sty, {\n          bpref: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-radius/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-shadow/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-shadow/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-shadow/index.js\n * @brief shadow effect for mofron\n *        this effect makes the component has a shadow.\n * @feature the size changes according to the value of the 'value' parameter.\n *          the blur percentage changes according to the value of the 'blur' parameter.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @param color parameter\n   * @short value,color\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Shadow');\n      this.shortForm('value', 'color');\n      this.transition([\"box-shadow\", \"webkit-box-shadow\", \"-moz-box-shadow\", \"-o-box-shadow\", \"-ms-box-shadow\"]);\n\n      /* init config */\n      this.confmng().add(\"value\", {\n        type: \"size\",\n        init: \"0.015rem\"\n      });\n      this.confmng().add(\"blur\", {\n        type: \"size\",\n        init: \"0rem\"\n      });\n      this.confmng().add('color', {\n        type: \"color\",\n        init: [190, 190, 190]\n      });\n\n      /* set config */\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * shadow size\n   *\n   * @param (string (size)) shadow size (css value)\n   * @return (string (size)) shadow size (css value)\n   * @type parameter\n   */\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * blur size value\n   * \n   * @param (string (size)) blur size value\n   * @return (string (size)) blur size value\n   * @type parameter\n   */\n  blur(prm) {\n    try {\n      return this.confmng(\"blur\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * shadow color\n   *\n   * @param (string (size)) shadow color (css value)\n   * @return (string (size)) shadow color (css value)\n   * @type parameter\n   */\n  color(prm) {\n    try {\n      return this.confmng(\"color\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * effect contents\n   * \n   * @param (component) target componet\n   * @type private\n   */\n  contents(cmp) {\n    try {\n      let str_val = this.value().toString();\n      let sum_val = comutl.sizesum(str_val, comutl.sizesum(str_val, str_val));\n      let set_val = {\n        \"box-shadow\": sum_val + ' ' + sum_val + ' ' + this.blur().toString() + ' ' + '0rem ' + this.color().toString()\n      };\n      cmp.style(set_val, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-shadow/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-click/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-event-click/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-event-click/index.js\n * @brief click event for mofron component\n *        it executes an event function when the component is clicked\n * ## event function parameter\n *  - component: event target component object\n *  - object: MouseEvent object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nconst Common = __webpack_require__(/*! mofron-event-common */ \"./node_modules/mofron-event-common/index.js\");\nmodule.exports = class extends Common {\n  /**\n   * initialize click event\n   * \n   * @param (mixed) listener parameter\n   *                key-value: event config\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Click\");\n      this.shortForm(\"listener\");\n      /* init config */\n      this.confmng().add(\"pointer\", {\n        type: \"boolean\",\n        init: true\n      });\n      this.type(\"click\");\n      /* set config */\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * add click event to target component.\n   * \n   * @param (component) event target component\n   * @type private\n   */\n  contents(tgt) {\n    try {\n      super.contents(tgt);\n      if (true === this.pointer()) {\n        this.component().style({\n          'cursor': 'pointer'\n        }, {\n          passive: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * mouse cursor style\n   *\n   * @param (boolean) true: mouse-in cursor is pointer [default]\n   *                  false: mouse-in coursor is default\n   * @return (boolean) mouse-in cursor style\n   * @type parameter\n   */\n  pointer(flg) {\n    try {\n      return this.confmng(\"pointer\", flg);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-click/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-common/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-event-common/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-event-common/index.js\n * @brief common event for mofron\n *        set addEventListener of target object\n *        it is possible to use addEventListener() for general by setting the parameter of the type method.\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Event {\n  /**\n   * initialize common event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @short listener,type\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Common\");\n      this.shortForm(\"listener\", \"type\");\n      /* init config */\n      this.confmng().add(\"type\", {\n        type: \"string\"\n      });\n      /* set config */\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * event type\n   * \n   * @param (string) event type\n   * @return (string) event type\n   * @type parameter\n   */\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * event contents\n   * \n   * @param (mofron.class.Dom) event target dom\n   * @type private\n   */\n  contents(tgt_dom) {\n    try {\n      let evt_obj = this;\n      tgt_dom.getRawDom().addEventListener(this.type(), e => {\n        try {\n          evt_obj.execListener(e);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      }, false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-common/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-tap/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-event-tap/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-event-tap/index.js\n * @brief tap event for mofron\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Event {\n  /**\n   * initialize event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.name(\"Tap\");\n\n      /* init config */\n      this.confmng().add(\"taponly\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"status\", {\n        type: \"object\",\n        init: {\n          status: null,\n          target: null\n        }\n      });\n      let dev = comutl.accdev();\n      if ('mobile' === dev || 'tablet' === dev) {\n        this.confmng(\"taponly\", true);\n      } else {\n        this.confmng(\"taponly\", false);\n      }\n\n      /* set config */\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event contents\n   * \n   * @param (mofron.class.dom) target dom object\n   * @type private\n   */\n  contents(dom) {\n    try {\n      let evt_obj = this;\n      let find_id = (dm, id) => {\n        try {\n          if (dm.id() === id) {\n            return true;\n          }\n          let dm_chd = dm.child();\n          for (let idx in dm_chd) {\n            if (true === find_id(dm_chd[idx], id)) {\n              return true;\n            }\n          }\n          return false;\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      let touch_start = e => {\n        try {\n          let tlist = e.changedTouches;\n          for (let tidx = 0; tidx < tlist.length; tidx++) {\n            /* find touched dom */\n            if (true === find_id(dom, tlist[tidx].target.id)) {\n              /* hit */\n              evt_obj.status('start', tlist[tidx].target.id);\n              break;\n            }\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      document.addEventListener(\"touchstart\", touch_start, {\n        passive: false\n      });\n      let touch_move = e => {\n        try {\n          let tlist = e.changedTouches;\n          for (let tidx = 0; tidx < tlist.length; tidx++) {\n            /* find touched dom */\n            if (true === find_id(dom, tlist[tidx].target.id)) {\n              /* hit */\n              evt_obj.status(null);\n              break;\n            }\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      document.addEventListener(\"touchmove\", touch_move, {\n        passive: false\n      });\n      let touch_end = e => {\n        try {\n          let tlist = e.changedTouches;\n          for (let tidx = 0; tidx < tlist.length; tidx++) {\n            /* find touched dom */\n            if (true === find_id(dom, tlist[tidx].target.id)) {\n              /* hit */\n              let sts = evt_obj.status();\n              if ('start' === sts.status && tlist[tidx].target.id === sts.target) {\n                evt_obj.execListener(e);\n              }\n              evt_obj.status(null);\n              break;\n            }\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      document.addEventListener(\"touchend\", touch_end, {\n        passive: false\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  status(sts, tgt) {\n    try {\n      if (undefined === sts) {\n        return this.confmng('status');\n      } else if (null === sts) {\n        this.confmng('status', {\n          status: null,\n          target: null\n        });\n      } else {\n        this.confmng('status', {\n          status: sts,\n          target: tgt\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * tap only flag\n   * \n   * @param (boolean) true: ignore click,mouse event\n   *                  false: nothing to do\n   * @return (boolean) flag status\n   * @type parameter\n   */\n  taponly(prm) {\n    try {\n      return this.confmng(\"taponly\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-tap/index.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Base.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/core/Base.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Base.js\n * @brief basement class of mofron\n * @author simpart\n */\nconst comutl = mofron.util.common;\nconst ConfManager = __webpack_require__(/*! ./ConfManager.js */ \"./node_modules/mofron/src/core/ConfManager.js\");\nlet genid = () => {\n  try {\n    let ret_id = '_';\n    let loop = 0;\n    let val = 0;\n    for (loop = 0; loop < 8; loop++) {\n      val = Math.random() * 16 | 0;\n      ret_id += (loop == 12 ? 4 : loop == 16 ? val & 3 | 8 : val).toString(16);\n    }\n    return ret_id;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\nmodule.exports = class {\n  constructor() {\n    try {\n      this.m_confmng = new ConfManager();\n      /* init config */\n      this.confmng().add(\"name\", {\n        type: \"string\",\n        private: true\n      });\n      this.confmng().add(\"modname\", {\n        type: \"string\",\n        private: true,\n        list: true\n      });\n      this.confmng().add(\"id\", {\n        type: \"string\",\n        private: true,\n        init: genid()\n      });\n      this.confmng().add(\"data\", {\n        type: \"key-value\",\n        private: true\n      });\n      this.confmng().add(\"shortForm\", {\n        type: \"array\",\n        private: true,\n        init: []\n      });\n      this.modname(\"Base\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * config manager\n   * \n   * @param (string) config key\n   * @param (mixed) config data\n   * @param (mixed) config option\n   * @return (mixed) config data\n   */\n  confmng(key, val, opt) {\n    try {\n      return undefined === key ? this.m_confmng : this.m_confmng.conf(key, val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * object name setter/getter\n   * \n   * @param (string) object name\n   * @return (string) object name\n   */\n  name(key) {\n    try {\n      if (undefined !== key) {\n        mofron.objkey[key] = this;\n      }\n      return this.confmng(\"name\", key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * module name setter / getter\n   *\n   * @param (string) module name\n   * @return (string) module name\n   */\n  modname(prm) {\n    try {\n      let ret = this.confmng(\"modname\", prm);\n      return undefined !== ret ? ret[ret.length - 1] : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * module id getter\n   * \n   * @return (string) module id\n   */\n  id() {\n    try {\n      return this.confmng().get(\"id\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * data buffer\n   * \n   * @param (string) buffer key\n   * @param (mixed) buffer data\n   *                undefined: call as getter\n   * @return (mixed) buffer data\n   */\n  data(key, val) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      let dat = this.confmng().get(\"data\");\n      if (undefined === val) {\n        /* getter */\n        return undefined === dat[key] ? null : dat[key];\n      }\n      /* setter */\n      dat[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * short form parameter setter/getter\n   * \n   * @param (string) \n   */\n  shortForm() {\n    try {\n      if (0 === arguments.length) {\n        return this.confmng().get(\"shortForm\");\n      }\n      let val = [];\n      for (let aidx in arguments) {\n        val.push(arguments[aidx]);\n      }\n      this.confmng(\"shortForm\", val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * execute config\n   * \n   * @param (mixed) config data\n   * @return (mixed) config list\n   */\n  config() {\n    try {\n      /* get argument */\n      if (0 === arguments.length) {\n        /* getter */\n        let cnf_ret = this.confmng().get();\n        //delete cnf_ret.style;\n        return cnf_ret;\n      }\n      let arg = new mofron.class.ConfArg();\n      arg.param(arguments);\n      /* setter */\n      if (1 === arguments.length && comutl.isinc(arguments[0], \"ConfArg\")) {\n        arguments[0].exec(this, this.shortForm());\n      } else if (1 < arg.param().length || !(\"object\" === typeof arguments[0] && false === Array.isArray(arguments[0]) && false === comutl.isinc(arguments[0], \"Base\"))) {\n        /* short form */\n        arg.exec(this, this.shortForm());\n      } else {\n        /* config */\n        for (let cf_idx in arguments[0]) {\n          if (\"function\" !== typeof this[cf_idx]) {\n            console.warn(\"invalid function: \" + cf_idx);\n            continue;\n          }\n          if (true !== comutl.isinc(arguments[0][cf_idx], \"ConfArg\")) {\n            this[cf_idx](arguments[0][cf_idx]);\n          } else {\n            arguments[0][cf_idx].exec(this, cf_idx);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Base.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/ConfManager.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/ConfManager.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file ConfManager.js\n * @brief config manager for mofron modules. it suply accessor functions to object.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class {\n  constructor() {\n    try {\n      this.m_conf = {};\n      this.m_opt = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  conf(key, val, opt) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      return undefined === val ? this.get(key, opt) : this.set(key, val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  add(key, opt) {\n    try {\n      if (\"object\" !== typeof opt || true === Array.isArray(opt) || true === comutl.isinc(opt, \"Base\")) {\n        throw new Error(\"invalid parameter\");\n      }\n      this.m_opt[key] = opt;\n      if (\"key-value\" === opt.type) {\n        this.m_conf[key] = {};\n        return;\n      } else if (true === opt.list) {\n        this.m_conf[key] = [];\n        return;\n      }\n      if (undefined !== opt.init) {\n        this.set(key, opt.init);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  get(key, opt) {\n    try {\n      if (undefined === key) {\n        /* get all config */\n        let ret = {};\n        for (let cidx in this.m_conf) {\n          if (true === this.m_opt[cidx].private) {\n            continue;\n          }\n          ret[cidx] = this.m_conf[cidx];\n        }\n        return ret;\n      } else if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      let pvt = undefined !== this.m_conf[key + \"_private\"] ? true : false;\n      if ('object' === typeof opt && undefined !== opt.private) {\n        pvt = opt.private;\n      }\n      /* return config */\n      let ret = undefined !== this.m_conf[key] ? this.m_conf[key] : null;\n      if (null !== ret && true === pvt) {\n        let pvt_ret = this.m_conf[key + \"_private\"];\n        if (true === this.m_opt[key].list) {\n          return pvt_ret.concat(ret);\n        } else if (\"key-value\" === this.m_opt[key].type) {\n          Object.assign(ret, pvt_ret);\n        }\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  chkValue(key, val) {\n    try {\n      let opt = this.m_opt[key];\n      if (undefined === opt || undefined === opt.type) {\n        throw new Error(\"could not find :\" + key);\n      }\n      if (\"color\" === opt.type) {\n        let clr = comutl.getcolor(val);\n        return null === clr ? clr : clr.toString();\n      } else if (\"size\" === opt.type) {\n        comutl.getsize(val);\n        return val;\n      } else if (\"event\" === opt.type) {\n        if (true !== Array.isArray(val) || \"function\" !== typeof val[0]) {\n          throw new Error('invalid parameter');\n        }\n        return val;\n      } else if (\"array\" === opt.type) {\n        if (false === Array.isArray(val)) {\n          throw new Error('invalid parameter');\n        }\n      } else if (\"key-value\" === opt.type) {\n        if (\"object\" !== typeof val || true === Array.isArray(val) || true === comutl.isinc(val, \"Base\")) {\n          throw new Error('invalid parameter');\n        }\n      } else if (true === comutl.isinc(val, 'Base')) {\n        //if ( (false === comutl.isinc(val, opt.type)) &&\n        //     (opt.type !== typeof val) ) {\n        if (false === comutl.isinc(val, opt.type)) {\n          throw new Error('invalid parameter');\n        }\n      } else if (opt.type !== typeof val) {\n        throw new Error('invalid parameter');\n      }\n      return val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  set(key, val, opt) {\n    try {\n      if (\"string\" !== typeof key || undefined === this.m_opt[key]) {\n        throw new Error(\"invalid parameter\");\n      }\n      if (true === this.m_opt[key].list && true === Array.isArray(val) && \"array\" !== this.m_opt[key].type && \"event\" !== this.m_opt[key].type) {\n        for (let vidx in val) {\n          this.set(key, val[vidx], opt);\n        }\n        return;\n      }\n      let set_val = this.chkValue(key, val);\n      let set_key = key;\n      if (undefined !== opt && true === opt.private) {\n        set_key = key + \"_private\";\n        if (undefined === this.m_opt[set_key]) {\n          this.m_opt[set_key] = {};\n          /* initialize priavte key */\n          for (let opt_idx in this.m_opt[key]) {\n            this.m_opt[set_key][opt_idx] = this.m_opt[key][opt_idx];\n          }\n          this.m_opt[set_key].private = true;\n          if (undefined !== this.m_opt[set_key].init) {\n            this.m_conf[set_key] = this.m_opt[set_key].init;\n          } else if (true === this.m_opt[set_key].list) {\n            this.m_conf[set_key] = [];\n          } else if (\"key-value\" === this.m_opt[set_key].type) {\n            this.m_conf[set_key] = {};\n          }\n        }\n      }\n      if (true === this.m_opt[set_key].list) {\n        this.m_conf[set_key].push(set_val);\n      } else if (\"key-value\" === this.m_opt[set_key].type) {\n        for (let vidx in val) {\n          this.m_conf[set_key][vidx] = val[vidx];\n        }\n      } else {\n        if (true === Array.isArray(this.m_opt[set_key].select)) {\n          let exs = false;\n          for (let sidx in this.m_opt[set_key].select) {\n            if (set_val === this.m_opt[set_key].select[sidx]) {\n              exs = true;\n              break;\n            }\n          }\n          if (false === exs) {\n            throw new Error(\"invald parameter\");\n          }\n        }\n        this.m_conf[set_key] = set_val;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  delete(key) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      delete this.m_conf[key];\n      this.add(key, this.m_opt[key]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ConfManager.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Document.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/core/Document.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Window.js\n * @brief mofron window class\n */\nconst Base = __webpack_require__(/*! ./Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nconst comutl = __webpack_require__(/*! ./../util/common.js */ \"./node_modules/mofron/src/util/common.js\");\nmodule.exports = class extends mofron.class.Component {\n  constructor() {\n    try {\n      super();\n      this.modname('Document');\n      this.confmng().add(\"event\", {\n        type: \"Event\",\n        list: true\n      });\n      this.confmng().add(\"styleDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      let dom = new mofron.class.Dom();\n      dom.m_rawdom = document.body;\n      this.confmng(\"rootDom\", dom);\n      this.confmng(\"styleDom\", dom);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  getRawDom() {\n    return document;\n  }\n  style(kv) {\n    try {\n      this.styleDom().style(kv);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  event(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return this.confmng(\"event\");\n      }\n      /* setter */\n      this.confmng(\"event\", prm);\n      //prm.component(this);\n      prm.contents(this);\n      prm.isInited(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Document.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/ModConf.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/ModConf.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file ModConf.js\n * @brief module config interface for mofron component\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ./Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nmodule.exports = class extends Base {\n  constructor(po) {\n    try {\n      super(po);\n      this.modname('ModConf');\n      /* init config */\n      this.confmng().add(\"component\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"tag\", {\n        type: \"string\"\n      });\n      this.confmng().add(\"isInited\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"suspend\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"innerTgt\", {\n        type: \"boolean\",\n        init: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  component(prm) {\n    try {\n      return this.confmng(\"component\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  execute() {\n    console.warn('not implement');\n  }\n  contents(p1) {\n    console.warn('not implement');\n  }\n  tag(prm) {\n    try {\n      return this.confmng(\"tag\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isInited(prm) {\n    try {\n      return this.confmng(\"isInited\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  suspend(prm) {\n    try {\n      return this.confmng(\"suspend\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  innerTgt(prm) {\n    try {\n      return this.confmng(\"innerTgt\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ModConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Window.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/core/Window.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Window.js\n * @brief mofron window class\n */\n//const Base   = require(\"./Base.js\");\n//const Component = require(\"../tag/Component.js\");\nconst comutl = __webpack_require__(/*! ./../util/common.js */ \"./node_modules/mofron/src/util/common.js\");\nmodule.exports = class extends mofron.class.Component {\n  constructor() {\n    try {\n      super();\n      this.modname('Window');\n      this.confmng().add(\"landscapeEvent\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"portraitEvent\", {\n        type: \"event\",\n        list: true\n      });\n      //this.confmng().add(\"event\", { type: \"Event\", list: true });\n\n      this.initOrientation();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isPortrait() {\n    try {\n      return window.innerHeight > window.innerWidth ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isLandscape() {\n    try {\n      return window.innerHeight < window.innerWidth ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  resizeEvent(func, prm, tlag) {\n    try {\n      let que_buf = null;\n      let param = prm;\n      let time_lag = undefined === tlag ? 200 : tlag;\n      if ('function' !== typeof func || 'number' !== typeof time_lag) {\n        throw new Error('invalid parameter');\n      }\n      window.addEventListener('resize', () => {\n        try {\n          clearTimeout(que_buf);\n          que_buf = setTimeout(func, time_lag, param);\n        } catch (e) {\n          console.error(e.stack);\n          throw new Error();\n        }\n      }, false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  initOrientation() {\n    try {\n      if (undefined !== screen.orientation && null === screen.orientation.onchange) {\n        screen.orientation.onchange = this.orientationHandler;\n      } else if (null === screen.onmozorientationchange) {\n        screen.onmozorientationchange = this.orientationHandler;\n      } else if (null === screen.onmsorientationchange) {\n        screen.onmsorientationchange = this.orientationHandler;\n      } else {\n        window.addEventListener(\"orientationchange\", this.orientationHandler);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  orientationHandler(evt) {\n    try {\n      let ef = null;\n      if (\"landscape-primary\" === screen.mozOrientation || \"landscape-secondary\" === screen.mozOrientation || \"landscape-primary\" === screen.orientation.type || \"landscape-secondary\" === screen.orientation.type) {\n        /* landscape event */\n        if (\"function\" === typeof this[\"landscapeEvent\"]) {\n          ef = this.landscapeEvent();\n        }\n      } else if (\"portrait-primary\" === screen.mozOrientation || \"portrait-secondary\" === screen.mozOrientation || \"portrait-primary\" === screen.orientation.type || \"portrait-secondary\" === screen.orientation.type) {\n        /* vertical event */\n        if (\"function\" === typeof this[\"portraitEvent\"]) {\n          ef = this.portraitEvent();\n        }\n      } else {\n        if (window.innerHeight < window.innerWidth) {\n          /* landscape event */\n          if (\"function\" === typeof this[\"landscapeEvent\"]) {\n            ef = this.landscapeEvent();\n          }\n        } else {\n          /* portrait event */\n          if (\"function\" === typeof this[\"portraitEvent\"]) {\n            ef = this.portraitEvent();\n          }\n        }\n      }\n      for (let eidx in ef) {\n        ef[eidx].exec(this, evt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  landscapeEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        return this.confmng(\"landscapeEvent\");\n      }\n      this.confmng(\"landscapeEvent\", [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  portraitEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        return this.confmng(\"portraitEvent\");\n      }\n      this.confmng(\"portraitEvent\", [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  eventDom() {\n    return this;\n  }\n  getRawDom() {\n    return window;\n  }\n  event(prm) {\n    try {\n      let ret = super.event(prm);\n      if (undefined === prm) {\n        return ret;\n      }\n      if (true === comutl.isinc(prm, \"Event\")) {\n        prm.execute();\n      } else if (true === Array.isArray(prm)) {\n        for (let pidx in prm) {\n          prm[pidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Window.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Attrs.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Attrs.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Attrs.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Attrs');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().setAttribute(key, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domRem(key) {\n    try {\n      this.dom().getRawDom().removeAttribute(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get attribute value from rawdom\n   *\n   * @param key : (string) style key\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n  domGet(key) {\n    try {\n      return this.dom().getRawDom().getAttribute(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n      for (let cidx in conts) {\n        ret += null === conts[cidx] ? cidx : cidx + '=\"' + conts[cidx] + '\"';\n        ret += \" \";\n      }\n      return \"\" === ret ? \"\" : ret.substring(0, ret.length - 1);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Attrs.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Class.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Class.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Class.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Class');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  set(prm, opt) {\n    try {\n      if (!(\"string\" === typeof prm || true === Array.isArray(prm))) {\n        throw new Error('invalid parameter');\n      }\n      let set_prm = {};\n      if (\"string\" === typeof prm) {\n        set_prm[prm] = \"\";\n      } else {\n        for (let pidx in prm) {\n          if (\"string\" !== typeof prm[pidx]) {\n            throw new Error(\"invalid parameter\");\n          }\n          set_prm[prm[pidx]] = \"\";\n        }\n      }\n      super.set(set_prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  get() {\n    try {\n      let ret = [];\n      let cls = super.get();\n      for (let cidx in cls) {\n        ret.push(cidx);\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set class name to rowdom\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().classList.add(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domRem(key) {\n    try {\n      this.dom().getRawDom().classList.remove(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get class name from rawdom\n   *\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n  domGet() {\n    try {\n      let clnm = this.dom().getRawDom().className;\n      if (undefined === clnm || null === clnm || '' === clnm) {\n        return null;\n      }\n      return clnm.split(' ');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n      for (let idx in conts) {\n        ret += conts[idx] + \" \";\n      }\n      return '' === ret ? '' : 'class=\"' + ret.substring(0, ret.length - 1) + '\"';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Class.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Dom.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Dom.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Dom.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nconst Class = __webpack_require__(/*! ./Class.js */ \"./node_modules/mofron/src/core/dom/Class.js\");\nconst Style = __webpack_require__(/*! ./Style.js */ \"./node_modules/mofron/src/core/dom/Style.js\");\nconst Attrs = __webpack_require__(/*! ./Attrs.js */ \"./node_modules/mofron/src/core/dom/Attrs.js\");\nconst Props = __webpack_require__(/*! ./Props.js */ \"./node_modules/mofron/src/core/dom/Props.js\");\nconst Tree = __webpack_require__(/*! ../tree/Tree.js */ \"./node_modules/mofron/src/core/tree/Tree.js\");\nconst IDX_CLASS = 0;\nconst IDX_STYLE = 1;\nconst IDX_ATTRS = 2;\nconst IDX_PROPS = 3;\nmodule.exports = class extends Base {\n  /**\n   * initialize member\n   *\n   */\n  constructor(tc, cmp) {\n    try {\n      super();\n      this.modname('Dom');\n      this.confmng().add(\"tag\", {\n        type: \"string\"\n      });\n      this.confmng().add(\"component\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"text\", {\n        type: \"string\",\n        init: \"\"\n      });\n      this.confmng().add(\"dummy\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.m_tree = new Tree(this);\n      this.m_rawdom = null;\n      this.m_conf = [new Class(this), new Style(this), new Attrs(this), new Props(this)];\n      if (\"string\" === typeof tc) {\n        this.tag(tc);\n        this.component(cmp);\n      } else if (undefined !== tc) {\n        this.config(tc);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * tag name setter / getter\n   *\n   * @param tg : (string) tag name (option)\n   * @return (string) tag name\n   */\n  tag(tg) {\n    try {\n      return this.confmng(\"tag\", tg);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * component getter / setter\n   * \n   * @param cmp (object) mofron.Component\n   * @return (object) mofron.Component\n   */\n  component(cmp) {\n    try {\n      return this.confmng(\"component\", cmp);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  getTree() {\n    try {\n      return this.m_tree;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  child(chd, idx) {\n    try {\n      if (undefined === chd) {\n        /* getter */\n        return this.m_tree.getChild();\n      }\n      /* setter */\n      this.m_tree.addChild(chd, idx);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  parent(prm) {\n    try {\n      return this.m_tree.parent(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  conf(k_kv, v_opt, idx, opt) {\n    try {\n      let cnf = this.m_conf[idx];\n      if (undefined === k_kv) {\n        /* get dom-config object */\n        return cnf;\n      } else if ('string' === typeof k_kv && undefined === v_opt) {\n        /* getter */\n        return cnf.get(k_kv);\n      }\n      /* setter */\n      if ('object' === typeof k_kv) {\n        cnf.set(k_kv, v_opt);\n      } else if ('string' === typeof k_kv) {\n        let set_kv = {};\n        set_kv[k_kv] = v_opt;\n        cnf.set(set_kv, opt);\n      }\n      this.value(null);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * style setter / getter\n   *\n   * @param kv : (object) key-value object\n   * @param opt: (object) option\n   * @return (string) : value of style\n   * @return (object) : style object\n   */\n  style(kv, opt) {\n    try {\n      if (undefined !== opt && true === opt.bpref) {\n        for (let key in kv) {\n          kv[\"webkit-\" + key] = kv[key];\n          kv[\"-moz-\" + key] = kv[key];\n          kv[\"-o-\" + key] = kv[key];\n          kv[\"-ms-\" + key] = kv[key];\n        }\n      }\n      return this.conf(kv, opt, IDX_STYLE);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * tag attribute setter / getter\n   *\n   * @param kv  : (object/string) key-value object / key of attribute\n   * @param val : (object) value of attribute\n   * @return\n   */\n  attrs(k_kv, v_opt, opt) {\n    try {\n      return this.conf(k_kv, v_opt, IDX_ATTRS, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * dom property setter / getter\n   * \n   * @param kv  : (object/string) key-value object / key of\n   * @param val : (object)  value of property\n   */\n  props(k_kv, v_opt, opt) {\n    try {\n      return this.conf(k_kv, v_opt, IDX_PROPS);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * tag class name setter / getter\n   * \n   * @param name : (string) class name\n   */\n  class(prm, opt) {\n    try {\n      if (undefined === prm) {\n        return this.conf(undefined === opt ? undefined : \"class\", opt, IDX_CLASS);\n      }\n      this.conf(\"string\" === typeof prm ? [prm] : prm, opt, IDX_CLASS);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * tag contents text setter / getter\n   * \n   * @param cnt : (string) tag contents (option)\n   * @return (string) tag contents\n   */\n  text(prm) {\n    try {\n      let ret = this.confmng(\"text\", prm);\n      if (undefined !== prm && true === this.isPushed()) {\n        this.getRawDom().innerHTML = prm;\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * dom string getter\n   *\n   * @return (string) dom string\n   */\n  value() {\n    try {\n      let chd = this.child();\n      let chd_ret = '';\n      for (let cidx in chd) {\n        chd_ret += chd[cidx].value();\n      }\n      if (true === this.dummy()) {\n        return chd_ret;\n      }\n      let ret = '<' + this.tag() + ' ';\n      /* set id attribute */\n      ret += 'id=\"' + this.id() + '\" ';\n      /* set dom config */\n      let cnf = this.m_conf;\n      let cnf_val = null;\n      for (var idx in cnf) {\n        let cnf_val = cnf[idx].toString();\n        if (\"\" !== cnf_val) {\n          ret += cnf_val + \" \";\n        }\n      }\n      ret += '>';\n      /* set tag contents */\n      ret += this.text();\n      /* check single */\n      if (true === is_single(this.tag())) {\n        return ret;\n      }\n      /* set child value */\n      ret += chd_ret;\n      return ret + '</' + this.tag() + '>';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * draw dom to target dom\n   * \n   * @param (key-value) push option\n   *     target   : push target object\n   *     child    : child flag\n   *     position : position of insertAdjacentHTML parameter\n   */\n  push(opt) {\n    try {\n      if (true === mofron.ssr) {\n        return;\n      } else if (undefined === opt) {\n        throw new Error(\"invalid parameter\");\n      }\n      if (true !== opt.child) {\n        opt.target.insertAdjacentHTML(undefined === opt.position ? 'beforeend' : opt.position, this.value());\n      }\n      let props = this.props().get();\n      if (true === this.dummy()) {\n        this.m_rawdom = null !== this.parent() ? this.parent().getRawDom() : null;\n      } else {\n        if (null !== this.parent()) {\n          this.m_rawdom = this.parent().getRawDom().querySelector(\"#\" + this.id());\n        } else {\n          this.m_rawdom = document.body.querySelector(\"#\" + this.id());\n        }\n      }\n      this.props(props); // set property\n\n      /* notify push to children */\n      let chd = this.child();\n      for (let cidx in chd) {\n        chd[cidx].push({\n          target: this.m_rawdom,\n          child: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get adom status\n   *\n   * @return (boolean) true : this adom had pushed\n   * @return (boolean) false : this adom had not pushed\n   */\n  isPushed() {\n    try {\n      return null === this.m_rawdom ? false : true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get pushed dom object from blowser\n   *\n   * @return (object) raw dom object\n   */\n  getRawDom() {\n    try {\n      if (false === this.isPushed()) {\n        throw new Error('this dom is not pushed yet');\n      }\n      return this.m_rawdom;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  destroy() {\n    try {\n      /* remove this object from parent dom */\n      if (true === this.isPushed()) {\n        this.getRawDom().remove();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  dummy(prm) {\n    try {\n      return this.confmng(\"dummy\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nlet is_single = prm => {\n  try {\n    if (\"br\" === prm || \"hr\" === prm || \"input\" === prm || \"img\" === prm) {\n      return true;\n    }\n    return false;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Dom.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/DomConf.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/DomConf.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file DomConf.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends Base {\n  constructor(dom) {\n    try {\n      super();\n      this.modname(\"DomConf\");\n      this.confmng().add(\"lock\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"dom\", {\n        type: \"Dom\"\n      });\n      this.confmng().add(\"listener\", {\n        type: \"array\",\n        list: true\n      });\n      this.dom(dom);\n      this.m_conts = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  dom(prm) {\n    try {\n      return this.confmng(\"dom\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  lock(key, val) {\n    try {\n      let lock = this.confmng().get(\"lock\");\n      if (undefined === val) {\n        /* getter */\n        return undefined === lock[key] ? false : lock[key];\n      }\n      /* setter */\n      if (\"boolean\" !== typeof val) {\n        throw new Error(\"invalid parameter\");\n      }\n      lock[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  chkval(kv) {\n    try {\n      if (!(\"object\" === typeof kv && false === Array.isArray(kv) && false === comutl.isinc(kv, \"Base\"))) {\n        throw new Error('invalid parameter');\n      }\n      for (let key in kv) {\n        if (null !== kv[key] && \"object\" === typeof kv[key]) {\n          throw new Error(\"invalid parameter\");\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  set(kv, opt) {\n    try {\n      this.chkval(kv);\n      let p_opt = undefined === opt ? {} : opt;\n      let lis = [];\n      for (let key in kv) {\n        let old_kv = {};\n        let new_kv = {};\n        old_kv[key] = undefined === this.m_conts[key] ? null : this.m_conts[key];\n        new_kv[key] = kv[key];\n        if (null === kv[key]) {\n          /* delete config */\n          this.rem(key);\n          lis = this.listener(key);\n          for (let lidx in lis) {\n            lis[lidx][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx][1]);\n          }\n          if (true === p_opt.lock) {\n            this.lock(key, true);\n          }\n          continue;\n        }\n        /* setter */\n        if (true === p_opt.passive) {\n          if (null === this.get(key)) {\n            this.m_conts[key] = kv[key];\n          } else {\n            continue;\n          }\n        } else if (true === p_opt.forced) {\n          this.m_conts[key] = kv[key];\n          this.lock(key, false);\n        } else {\n          if (true === this.lock(key)) {\n            continue;\n          }\n          this.m_conts[key] = kv[key];\n        }\n        if (true === p_opt.lock) {\n          this.lock(key, true);\n        }\n        if (true === this.dom().isPushed()) {\n          /* target dom is already rendered */\n          this.domSet(key, kv[key]);\n        }\n        lis = this.listener(key);\n        for (let lidx2 in lis) {\n          lis[lidx2][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx2][1]);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  get(key) {\n    try {\n      if (false === this.dom().isPushed()) {\n        if (undefined === key) {\n          return this.m_conts;\n        }\n        return undefined === this.m_conts[key] ? null : this.m_conts[key];\n      } else {\n        /* target is already rendered */\n        return undefined == this.domGet(key) ? null : this.domGet(key);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  rem(key) {\n    try {\n      if (undefined !== this.m_conts[key]) {\n        delete this.m_conts[key];\n      }\n      if (true === this.dom().isPushed()) {\n        /* target dom is already rendered */\n        this.domRem(key);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domRem(key) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domSet(key, val) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domGet(key) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  listener(key, fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        /* getter */\n        let lis = this.confmng(\"listener\");\n        if (undefined === key) {\n          return lis;\n        }\n        let ret = [];\n        for (let lidx in lis) {\n          if (key === lis[lidx][0]) {\n            ret.push([lis[lidx][1], lis[lidx][2]]);\n          }\n        }\n        return ret;\n      }\n      if (\"string\" !== typeof key || \"function\" !== typeof fnc) {\n        throw new Error(\"invalid parameter\");\n      }\n      this.confmng(\"listener\", [key, fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/DomConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Props.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Props.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Props.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target dom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Prop');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  chkval(kv) {\n    try {\n      if (!(\"object\" === typeof kv && false === Array.isArray(kv) && false === comutl.isinc(kv, \"Base\"))) {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set property\n   *\n   * @param key : (string) property key\n   * @param val : (string) property value\n   */\n  domSet(key, val) {\n    try {\n      if (undefined === this.dom().getRawDom()[key]) {\n        throw new Error(key + ' is unknown property');\n      }\n      this.dom().getRawDom()[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domRem(key) {\n    try {\n      if (undefined === this.dom().getRawDom()[key]) {\n        return;\n      }\n      delete this.dom().getRawDom()[key];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get property value from rawdom\n   *\n   * @param key : (string) property key\n   * @return (string) property value\n   */\n  domGet(key) {\n    try {\n      let ret = this.dom().getRawDom()[key];\n      return \"\" === ret ? undefined : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toString() {\n    try {\n      return \"\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Props.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Style.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Style.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Style.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Style');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().style[getcamel(key)] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get style value from rawdom\n   *\n   * @param key : (string) style key\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n  domGet(key) {\n    try {\n      if (undefined === key) {\n        return this.dom().getRawDom().style;\n      }\n      let val = this.dom().getRawDom().style[getcamel(key)];\n      return undefined === val || \"\" === val ? null : val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  domRem(key) {\n    try {\n      this.dom().getRawDom().style[getcamel(key)] = \"\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n      for (let cidx in conts) {\n        ret += cidx + ':' + conts[cidx] + ';';\n      }\n      return '' === ret ? '' : 'style=\"' + ret + '\"';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nlet getcamel = prm => {\n  try {\n    if ('string' !== typeof prm) {\n      throw new Error('invalid parameter');\n    }\n    if (prm.length - 1 === prm.lastIndexOf('-')) {\n      throw new Error('invalid parameter');\n    }\n    var skip = false;\n    if (0 === prm.indexOf('-')) {\n      skip = true;\n    }\n    var ret_val = prm;\n    var ret_buf = null;\n    var up_str = null;\n    var idx = null;\n    while (true) {\n      idx = ret_val.indexOf('-');\n      if (-1 === idx) {\n        break;\n      }\n      up_str = ret_val.charAt(idx + 1).toUpperCase();\n      ret_buf = ret_val.substr(0, idx);\n      if (true === skip) {\n        skip = false;\n        ret_val = ret_buf + ret_val.substr(idx + 1);\n      } else {\n        ret_val = ret_buf + up_str + ret_val.substr(idx + 2);\n      }\n    }\n    return ret_val;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Style.js?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js ***!
  \******************************************************************************************************************/
/***/ ((module) => {

eval("/**\n * @file namespace.js\n * @author simpart\n */\n//const Window = require(\"./Window.js\");\nmodule.exports = {\n  root: [],\n  window: null,\n  class: {},\n  objkey: {},\n  util: {}\n  //debug  : false\n};\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js?./node_modules/babel-loader/lib/index.js??ruleSet%5B1%5D.rules%5B0%5D.use");

/***/ }),

/***/ "./node_modules/mofron/src/core/tree/CompTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/CompTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file CompTree.js\n * @brief tree manager for component\n * @license MIT\n */\nconst Tree = __webpack_require__(/*! ./Tree.js */ \"./node_modules/mofron/src/core/tree/Tree.js\");\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends Tree {\n  addChild(chd, idx) {\n    try {\n      if (true === Array.isArray(chd)) {\n        /* parameter check */\n        for (let cidx in chd) {\n          this.addChild(chd[cidx], idx);\n        }\n        return;\n      }\n      /* set parent-child relation in dom layer */\n      let rdom = chd.rootDom();\n      if (undefined === idx) {\n        this.target().childDom().child(rdom);\n      } else {\n        let tgt_tree = this.target().childDom().getTree();\n        let t_idx = tgt_tree.getIndex(this.target().child()[idx].rootDom()[0]);\n        tgt_tree.addChild(rdom, t_idx);\n      }\n\n      /* set parent-child relation in component layer */\n      super.addChild(chd, idx);\n\n      /* check render */\n      if (true === this.target().isExists()) {\n        //let lo = chd.layout();\n        ///* layout */\n        //for(let lidx in lo) {\n        //    lo[lidx].execute();\n        //}\n        /* parent layout */\n        lo = this.target().layout();\n        for (let lidx2 in lo) {\n          lo[lidx2].execute();\n        }\n\n        /* theme */\n        cmputl.theme(chd, this.target().theme());\n        cmputl.theme(chd, cmputl.follow_theme(this.target()));\n\n        /* render child */\n        cmputl.render(chd);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  replace(o_chd, n_chd) {\n    try {\n      if (this.target().childDom().id() === o_chd.childDom().id()) {\n        /* old child is dom target, replace dom target */\n        this.target().childDom(n_chd.childDom());\n      }\n      /* set parent-child relation in component layer */\n      this.getChild().splice(this.getIndex(o_chd), 0, n_chd);\n      n_chd.parent(this.target());\n\n      /* set parent-child relation in dom layer */\n      let tgt_tree = o_chd.rootDom()[0].parent().getTree();\n      let rep_idx = tgt_tree.getIndex(o_chd.rootDom()[0]);\n      let n_rdom = n_chd.rootDom();\n      for (let ridx in n_rdom) {\n        tgt_tree.getChild().splice(rep_idx + parseInt(ridx), 0, n_rdom[ridx]);\n        n_rdom[ridx].parent(this.target().childDom());\n      }\n      if (true === o_chd.isExists()) {\n        cmputl.render(n_chd);\n        cmputl.initmconf(n_chd.parent(), \"layout\");\n      }\n      o_chd.destroy();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  delChild(chd) {\n    try {\n      /* release relational in dom layer */\n      let rdom = chd.rootDom();\n      for (let ridx in rdom) {\n        if (null !== rdom[ridx].parent()) {\n          rdom[ridx].parent().getTree().delChild(rdom[ridx]);\n        }\n      }\n      /* delete child component */\n      super.delChild(chd);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/CompTree.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/tree/Tree.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/Tree.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file Tree.js\n * @brief basement tree manager\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class {\n  constructor(tgt, elm) {\n    try {\n      this.m_parent = null;\n      this.m_child = [];\n      this.elemName(tgt.modname());\n      this.target(tgt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  elemName(prm) {\n    try {\n      if (undefined === prm) {\n        if (undefined === this.m_elemnm) {\n          throw new Error(\"could not find element name\");\n        }\n        return this.m_elemnm;\n      }\n      if (\"string\" !== typeof prm) {\n        throw new Error(\"invalid parameter\");\n      }\n      this.m_elemnm = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  target(prm) {\n    try {\n      if (undefined === prm) {\n        if (undefined === this.m_target) {\n          throw new Error(\"could not find target\");\n        }\n        return this.m_target;\n      }\n      if (false === comutl.isinc(prm, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n      this.m_target = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  getChild() {\n    try {\n      return this.m_child;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  addChild(chd, idx) {\n    try {\n      /* parameter check */\n      if (true === Array.isArray(chd)) {\n        for (let cidx in chd) {\n          this.addChild(chd[cidx], undefined !== idx ? idx + parseInt(cidx) : undefined);\n        }\n        return;\n      }\n      if (false === comutl.isinc(chd, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n      /* set parent-child relation */\n      chd.parent(this.target());\n      /* add child */\n      if (undefined === idx) {\n        this.getChild().push(chd);\n      } else {\n        this.getChild().splice(idx, 0, chd);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  delChild(chd) {\n    try {\n      let del_idx = this.getIndex(chd);\n      this.getChild().splice(del_idx, 1);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  parent(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return undefined === this.m_parent ? null : this.m_parent;\n      }\n      if (false === comutl.isinc(prm, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n      this.m_parent = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  getIndex(prm) {\n    try {\n      let chd = this.getChild();\n      for (let cidx in chd) {\n        if (chd[cidx].id() === prm.id()) {\n          return parseInt(cidx);\n        }\n      }\n      throw new Error(\"invalid parameter\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/Tree.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Component.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/tag/Component.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   Component.js\n * @brief  basement component class\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nconst CompTree = __webpack_require__(/*! ../core/tree/CompTree.js */ \"./node_modules/mofron/src/core/tree/CompTree.js\");\nconst Dom = mofron.class.Dom;\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nconst effutl = __webpack_require__(/*! ../util/effect.js */ \"./node_modules/mofron/src/util/effect.js\");\nmodule.exports = class extends Base {\n  /**\n   * initialize property, dom\n   *\n   * @param (mixed) component proterty\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Component\");\n      this.confmng().add(\"rootDom\", {\n        type: \"Dom\",\n        list: true,\n        private: true\n      });\n      this.confmng().add(\"childDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"styleDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"eventDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"layout\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"effect\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"event\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"renderEvent_before\", {\n        type: \"event\",\n        list: true,\n        private: true\n      });\n      this.confmng().add(\"renderEvent_after\", {\n        type: \"event\",\n        list: true,\n        private: true\n      });\n      this.confmng().add(\"style\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"theme\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"innerComp\", {\n        type: \"key-value\",\n        private: true\n      });\n      this.confmng().add(\"mainColor\", {\n        type: \"color\"\n      });\n      this.confmng().add(\"baseColor\", {\n        type: \"color\"\n      });\n      this.confmng().add(\"accentColor\", {\n        type: \"color\"\n      });\n\n      /* initialize member */\n      this.m_tree = new CompTree(this);\n\n      /*** set config ***/\n      this.shortForm(\"child\");\n\n      /* user config */\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /*** dom method ***/\n\n  /**\n   * dom setter / getter\n   * \n   * @return (object) dom object\n   */\n  rootDom(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        if (0 === this.confmng().get(\"rootDom\").length) {\n          this.initDomConts();\n        }\n        return this.confmng().get(\"rootDom\");\n      }\n      /* setter */\n      this.confmng().set(\"rootDom\", prm);\n      if (null === this.childDom()) {\n        this.childDom(this.rootDom()[0]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * dom target setter / getter\n   * \n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n  childDom(tgt) {\n    try {\n      this.rootDom();\n      let ret = this.confmng(\"childDom\", tgt);\n      if (null === ret) {\n        if (0 < this.rootDom().length) {\n          this.confmng(\"childDom\", this.rootDom()[0]);\n          return this.confmng(\"childDom\");\n        } else {\n          throw new Error(\"could not find child dom\");\n        }\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get style target dom\n   *\n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n  styleDom(tgt) {\n    try {\n      let ret = this.confmng(\"styleDom\", tgt);\n      return null === ret ? this.childDom() : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get event target dom\n   *\n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n  eventDom(tgt) {\n    try {\n      let ret = this.confmng(\"eventDom\", tgt);\n      return null === ret ? this.childDom() : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  renderEvent(prm, typ) {\n    try {\n      let type = undefined === typ ? \"after\" : typ;\n      if (undefined === prm) {\n        return this.confmng(\"renderEvent_\" + type);\n      }\n      this.confmng(\"renderEvent_\" + type, prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  beforeRender() {\n    try {\n      cmputl.chdloop(this, \"beforeRender\");\n      let evt = this.renderEvent(undefined, \"before\");\n      for (let eidx in evt) {\n        evt[0](this, evt[1]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  initDomConts(prm) {\n    try {\n      this.rootDom(new Dom(undefined === prm ? \"div\" : prm, this));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  afterRender() {\n    try {\n      cmputl.chdloop(this, \"afterRender\");\n      let evt = this.renderEvent(undefined, \"after\");\n      for (let eidx in evt) {\n        evt[0](this, evt[1]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  getTree() {\n    try {\n      return this.m_tree;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /*** child method ***/\n  /**\n   * child component setter / getter\n   * \n   * @param chd : (object) child component\n   * @param chd : (object) child component array\n   * @return (array) : childlen object\n   */\n  child(chd, idx) {\n    try {\n      this.rootDom();\n      let ct = true === cmputl.isinncmp(this) ? this.childDom().component().getTree() : this.getTree();\n      if (undefined === chd) {\n        /* getter */\n        return ct.getChild();\n      }\n      /* setter */\n      ct.addChild(chd, idx);\n      if (true === this.isExists() && true === cmputl.isinncmp(this)) {\n        /* perform layout on added components */\n        cmputl.initmconf(this, \"layout\");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  parent(prm) {\n    try {\n      return this.getTree().parent(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  innerComp(key, val, defcmp) {\n    try {\n      let incmp = this.confmng().get(\"innerComp\");\n      if (undefined === val) {\n        /* getter */\n        if (undefined === incmp[key]) {\n          this[key](new defcmp({}));\n        }\n        return incmp[key];\n      } else if (false === comutl.iscmp(val)) {\n        this.innerComp(key).config(val);\n        return;\n      }\n      /* setter */\n      if (undefined !== incmp[key]) {\n        if (false === comutl.isinc(val, incmp[key].modname())) {\n          throw new Error(\"invalid parameter\");\n        }\n        /* rewrite component, replace target child */\n        let pnt = incmp[key].parent();\n        if (null !== pnt) {\n          pnt.getTree().replace(incmp[key], val);\n        }\n      }\n      incmp[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /* component method */\n  /**\n   * execute effect\n   *\n   * @param (number) execute id\n   * @param (function, array) callback\n   * @return (boolean) execute result\n   */\n  execEffect(eid, cb, cbp) {\n    try {\n      return effutl.exec(cmputl.modconf(this, \"effect\"), eid, [cb, cbp]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isExists() {\n    try {\n      return this.childDom().isPushed();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /*** user config method ***/\n  /**\n   * style getter / setter\n   *\n   * @return (object) style object\n   */\n  style(kv, opt) {\n    try {\n      if (\"string\" === typeof kv) {\n        /* getter */\n        return this.styleDom().style(kv);\n      } else if (undefined === kv) {\n        return this.styleDom().style(kv).get();\n      }\n      this.styleDom().style(kv, opt);\n      this.confmng(\"style\", kv, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  layout(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"layout\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  effect(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"effect\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  event(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"event\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  accessConf() {\n    try {\n      let hit = false;\n      for (let arg_idx in arguments) {\n        hit = false;\n        if (undefined === arguments[arg_idx].access) {\n          if (true !== hit) {\n            /* set default config */\n            this.config(arguments[arg_idx].config);\n          }\n          break;\n        }\n        /* check access types */\n        let orit = arguments[arg_idx].access.orientation;\n        if (undefined !== orit) {\n          if ('portrait' === orit && true !== mofron.window.isPortrait() || 'landscape' === orit && true !== mofron.window.isLandscape()) {\n            continue;\n          }\n          delete arguments[arg_idx].access.orientation;\n        }\n        hit = comutl.chkacc(arguments[arg_idx].access);\n        if (true === hit) {\n          this.config(arguments[arg_idx].config);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * \n   */\n  theme(prm) {\n    try {\n      return this.confmng(\"theme\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  template(tmpl, prm) {\n    try {\n      if ('function' !== typeof tmpl) {\n        throw new Error('invalid parameter');\n      }\n      this.child(tmpl(prm));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  destroy() {\n    try {\n      /* destroy in component layer */\n      if (null === this.parent()) {\n        return;\n      }\n      this.parent().getTree().delChild(this);\n\n      /* destroy in dom layer */\n      let rdom = this.rootDom();\n      for (let ridx in rdom) {\n        rdom[ridx].destroy();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  size(x, y, opt) {\n    try {\n      if (undefined === x) {\n        /* getter */\n        return [this.width(), this.height()];\n      }\n      /* setter */\n      this.width(x, opt);\n      this.height(y, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  width(prm, opt) {\n    try {\n      return cmputl.size(this, \"width\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  height(prm, opt) {\n    try {\n      return cmputl.size(this, \"height\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /*** color method ***/\n  color(c1, c2, c3) {\n    try {\n      if (undefined === c1) {\n        /* getter */\n        return [this.mainColor(), this.baseColor(), this.accentColor()];\n      }\n      let clr_tgt = [\"mainColor\", \"baseColor\", \"accentColor\"];\n      for (let cidx in clr_tgt) {\n        if (undefined === arguments[cidx]) {\n          continue;\n        } else if (true === comutl.isinc(arguments[cidx], \"ConfArg\")) {\n          arguments[cidx].exec(this, clr_tgt[cidx]);\n        } else {\n          this[clr_tgt[cidx]](arguments[cidx]);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  mainColor(prm, opt) {\n    /* this is interface */\n    this.confmng(\"mainColor\", prm);\n    return null;\n  }\n  baseColor(clr, opt) {\n    try {\n      /* interface */\n      this.confmng(\"baseColor\", clr);\n      return cmputl.color(this, \"background\", clr, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  accentColor(prm, opt) {\n    /* this is interface */\n    return this.confmng(\"accentColor\", prm);\n  }\n  visible(flg, cbf, cbp) {\n    try {\n      return cmputl.visible(this, flg, cbf, cbp);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  config(p1, p2, p3, p4, p5) {\n    try {\n      this.rootDom();\n      if (0 === arguments.length || 1 === arguments.length && undefined === p1) {\n        return super.config();\n      }\n      super.config(p1, p2, p3, p4, p5);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Component.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Effect.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Effect.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Effect.js\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\nconst cmputl = mofron.util.component;\nconst comutl = mofron.util.common;\nconst effutl = mofron.util.effect;\nmodule.exports = class extends ModConf {\n  constructor(po) {\n    try {\n      super();\n      this.modname('Effect');\n      this.confmng().add(\"callback\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"otCallback\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"beforeEvent\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"order\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"eid\", {\n        type: \"number\",\n        init: -1\n      });\n      this.confmng().add(\"speed\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"delay\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"timing\", {\n        type: \"string\",\n        init: \"linear\",\n        select: [\"ease\", \"linear\", \"ease-in\", \"ease-out\", \"ease-in-out\"]\n      });\n      this.confmng().add(\"cubic\", {\n        type: \"array\"\n      });\n      this.confmng().add(\"transition\", {\n        type: \"string\",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * execute effect\n   * \n   * @param p2 (function) simple call back\n   */\n  execute() {\n    try {\n      if (true === this.isSkipped(this.eid(), this.order())) {\n        return;\n      }\n      let trans = false;\n      if (0 < this.speed() && null === this.component().style(\"transition\")) {\n        /* direct called execute() function  */\n        effutl.transition([this]);\n        trans = true;\n        this.otCallback((ts1, ts2, ts3) => {\n          try {\n            /* release transition */\n            cmputl.rstyle(this.component(), {\n              'transition': null\n            }, {\n              bpref: true\n            });\n            this.component().styleDom().style({\n              'transition': null\n            }, {\n              bpref: true\n            });\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, this);\n      }\n\n      /* execute effect */\n      let exec = exe_eff => {\n        try {\n          exe_eff.contents(exe_eff.component());\n          exe_eff.isInited(true);\n          setTimeout(exe_eff.exeCallback, exe_eff.speed() + exe_eff.delay(), exe_eff);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      exec(this);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  fexec() {\n    try {\n      let sus = this.suspend();\n      this.suspend(false);\n      this.execute();\n      this.suspend(sus);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  contents(eid, cmp) {}\n  transition(prm) {\n    try {\n      return this.confmng(\"transition\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  beforeEvent(fnc, prm) {\n    try {\n      return this.confmng(\"beforeEvent\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  otCallback(fnc, prm) {\n    try {\n      let ret = this.confmng(\"otCallback\", undefined === fnc ? undefined : [fnc, prm]);\n      if (undefined !== ret) {\n        this.confmng().delete(\"otCallback\");\n        return ret;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * @param p1 (array) [function, param, one time flag]\n   */\n  callback(fnc, prm) {\n    try {\n      return this.confmng(\"callback\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  exeCallback(eff) {\n    try {\n      /* execute callback */\n      let cb = eff.callback();\n      for (let cidx1 in cb) {\n        cb[cidx1][0](eff, eff.component(), cb[cidx1][1]);\n      }\n      let ocb = eff.otCallback();\n      for (let cidx2 in ocb) {\n        ocb[cidx2][0](eff, eff.component(), ocb[cidx2][1]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isSkipped(eid, ord) {\n    try {\n      if (true === this.suspend() || eid !== this.eid() || ord !== this.order()) {\n        return true;\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * execute order number setter/getter\n   *\n   * @param p1 (number) execute order number\n   * @param p1 (undefined) call as getter\n   * @return (number) execute order number\n   */\n  order(prm) {\n    try {\n      return this.confmng(\"order\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  eid(prm) {\n    try {\n      return this.confmng(\"eid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /*** default execute config ***/\n  /**\n   * effect speed setter/getter\n   *\n   * @param p1 (number) effect speed\n   * @param p1 (undefined) call as getter\n   * @return (number) effect speed\n   */\n  speed(prm) {\n    try {\n      return this.confmng(\"speed\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  delay(prm) {\n    try {\n      return this.confmng(\"delay\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  timing(prm) {\n    try {\n      return this.confmng(\"timing\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  cubicBezier(p1, p2, p3, p4) {\n    try {\n      if (undefined === p1) {\n        return this.confmng(\"cubic\");\n      }\n      if (\"number\" !== typeof p1 || \"number\" !== typeof p2 || \"number\" !== typeof p3 || \"number\" !== typeof p4) {\n        throw new Error(\"invalid parameter\");\n      }\n      this.confmng(\"cubic\", [p1, p2, p3, p4]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Effect.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Event.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/tag/Event.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file event.js\n * @author simpart\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends ModConf {\n  /**\n   * initialize member\n   *\n   */\n  constructor() {\n    try {\n      super();\n      this.modname('Event');\n      this.shortForm('listener');\n      this.confmng().add(\"listener\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"eid\", {\n        type: \"number\"\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * set function for event listener\n   *\n   * @param fnc : (function) function for event listener\n   * @param prm : (mixed) function parameter (option)\n   */\n  listener(fnc, prm) {\n    try {\n      return this.confmng(\"listener\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  execListener(eprm) {\n    try {\n      if (true === this.suspend()) {\n        return;\n      }\n      let lis = this.listener();\n      let prm = null;\n      for (let lidx in lis) {\n        lis[lidx][0](this.component(), eprm, lis[lidx][1]);\n      }\n      /* execute effect */\n      if (null !== this.eid()) {\n        this.component().execEffect(this.eid());\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  execute() {\n    try {\n      this.initevt();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  initevt() {\n    try {\n      if (false === this.isInited()) {\n        this.contents(this.component().eventDom());\n        this.isInited(true);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  eid(prm) {\n    try {\n      return this.confmng(\"eid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Event.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Layout.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Layout.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file layout/Base.js\n * @brief Base class of layout\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends ModConf {\n  constructor(po) {\n    try {\n      super();\n      this.modname('Layout');\n      this.confmng().add(\"skip\", {\n        type: \"Component\",\n        list: true\n      });\n      this.confmng().add(\"execlog\", {\n        type: \"Component\",\n        list: true,\n        private: true\n      });\n\n      //this.m_execnt = 0;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  execute() {\n    try {\n      let cmp_chd = this.component().child();\n      for (let cidx in cmp_chd) {\n        /* check skip */\n        if (true === this.isSkipped(cmp_chd[cidx])) {\n          continue;\n        }\n        if (false === this.isExeced(cmp_chd[cidx])) {\n          /* execute layout contents */\n          this.contents(parseInt(cidx), cmp_chd[cidx]);\n          this.confmng(\"execlog\", cmp_chd[cidx]);\n        }\n      }\n      this.isInited(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isExeced(cmp) {\n    try {\n      let elog = this.confmng(\"execlog\");\n      for (let eidx in elog) {\n        if (elog[eidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  contents(idx, tgt) {\n    console.warn('not implement');\n  }\n  skip(prm) {\n    try {\n      return this.confmng(\"skip\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  isSkipped(cmp) {\n    try {\n      let skp = this.skip();\n      for (let sidx in skp) {\n        if (skp[sidx].id() === cmp[cidx].id()) {\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Layout.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/type/Color.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Color.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nmodule.exports = class extends Base {\n  /**\n   * initialize member\n   *\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname('Color');\n      this.m_rgba = [null, null, null, null]; /* red, green, blue, alpha */\n      if (true === Array.isArray(prm)) {\n        this.rgba(prm[0], prm[1], prm[2], prm[3]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  rgb(r, g, b) {\n    try {\n      let ret = this.rgba(r, g, b);\n      return undefined !== ret ? [ret[0], ret[1], ret[2]] : undefined;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get rgba value\n   * \n   * @return (object) rgba array object\n   *   [0] -> (number) red value\n   *   [1] -> (number) green value\n   *   [2] -> (number) blue value\n   *   [3] -> (number) alpha value\n   */\n  rgba(red, green, blue, alpha) {\n    try {\n      if (undefined === red) {\n        /* getter */\n        return this.m_rgba;\n      }\n      /* setter */\n      var _red = red === undefined ? null : red;\n      var _green = green === undefined ? null : green;\n      var _blue = blue === undefined ? null : blue;\n      var _alpha = alpha === undefined ? 1 : alpha;\n      if (null === _red && null === _green && null === _blue) {} else if (null !== _red && null !== _green && null !== _blue) {\n        if ('number' !== typeof _red || 'number' !== typeof _green || 'number' !== typeof _blue) {\n          throw new Error('invalid parameter');\n        }\n      } else {\n        throw new Error('invalid parameter');\n      }\n      if ('number' !== typeof _alpha) {\n        throw new Error('invalid parameter');\n      }\n      this.m_rgba[0] = _red;\n      this.m_rgba[1] = _green;\n      this.m_rgba[2] = _blue;\n      this.m_rgba[3] = _alpha;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  /**\n   * get coloe style value\n   *\n   * @return (string) rgba(x,x,x,x)\n   * @return (string) none\n   * @note return 'none' if rgb is null.\n   */\n  toString() {\n    try {\n      let rgba = this.rgba();\n      let red = rgba[0];\n      let green = rgba[1];\n      let blue = rgba[2];\n      let alpha = rgba[3];\n      if (null === red && null === green && null === blue) {\n        return 'none';\n      }\n      return 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/Color.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/ConfArg.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/type/ConfArg.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file ConfArg.js\n * @brief config argument class\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends Base {\n  constructor() {\n    try {\n      super();\n      this.modname(\"ConfArg\");\n      this.param(arguments);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  exec(tgt, fnc) {\n    try {\n      let arg = this.param();\n      if (true === Array.isArray(fnc)) {\n        if (1 === fnc.length) {\n          this.exec(tgt, fnc[0]);\n        } else {\n          if (fnc.length < arg.length) {\n            throw new Error(\"mismatched config count\");\n          }\n          for (let aidx in arg) {\n            if (\"function\" !== typeof tgt[fnc[aidx]]) {\n              console.warn(\"invalid config: \" + fnc[aidx]);\n              continue;\n            }\n            if (true === comutl.isinc(arg[aidx], \"ConfArg\")) {\n              arg[aidx].exec(tgt, fnc[aidx]);\n            } else {\n              tgt[fnc[aidx]](arg[aidx]);\n            }\n          }\n        }\n        return;\n      } else if (\"string\" === typeof fnc) {\n        if (\"function\" !== typeof tgt[fnc]) {\n          console.warn(\"invalid config: \" + fnc);\n          return;\n        }\n        if (0 === arg.length) {\n          tgt[fnc]();\n        } else if (1 === arg.length) {\n          tgt[fnc](arg[0]);\n        } else if (2 === arg.length) {\n          tgt[fnc](arg[0], arg[1]);\n        } else if (3 === arg.length) {\n          tgt[fnc](arg[0], arg[1], arg[2]);\n        } else if (4 === arg.length) {\n          tgt[fnc](arg[0], arg[1], arg[2], arg[3]);\n        } else {\n          tgt[fnc](arg[0], arg[1], arg[2], arg[3], arg[4]);\n        }\n      } else {\n        throw new Error(\"invalid parameter\");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  param(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        if (undefined === this.m_param) {\n          throw new Error(\"could not find param\");\n        }\n        return this.m_param;\n      }\n      /* setter */\n      if (\"object\" !== typeof prm) {\n        throw new Error(\"invalid parameter\");\n      }\n      let arg = [];\n      let hit = false;\n      for (let pidx = prm.length; pidx >= 0; pidx--) {\n        if (true === hit) {\n          arg.unshift(prm[pidx]);\n        } else if (undefined !== prm[pidx]) {\n          arg.unshift(prm[pidx]);\n          hit = true;\n        }\n      }\n      this.m_param = arg;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  addParam(prm) {\n    try {\n      this.m_param.push(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/ConfArg.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/PullConf.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/PullConf.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file pullConf.js\n * @brief pull type config argument class\n * @author simpart\n */\nconst ConfArg = __webpack_require__(/*! ./ConfArg.js */ \"./node_modules/mofron/src/type/ConfArg.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends ConfArg {\n  constructor(prm) {\n    try {\n      if (!('object' === typeof prm && false === Array.isArray(prm) && false === comutl.isinc(prm, \"Base\"))) {\n        throw new Error(\"invalid parameter\");\n      }\n      super(prm);\n      this.modname(\"PullConf\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  exec(tgt, fnc) {\n    try {\n      tgt[fnc]().config(this.param()[0]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/PullConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Pixel.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Pixel.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Pixel.js\n * @brief pixel size data type\n * @author simpart\n */\nconst Size = __webpack_require__(/*! ./Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\nmodule.exports = class extends Size {\n  /**\n   *\n   */\n  constructor(prm) {\n    try {\n      super(prm, 'px');\n      this.modname('Pixel');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toPixel() {\n    try {\n      return this.value();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Pixel.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Rem.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Rem.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Rem.js\n * @brief rem size data type\n * @author simpart\n */\nconst Size = __webpack_require__(/*! ./Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\nconst comutl = mofron.util.common;\nmodule.exports = class extends Size {\n  /**\n   *\n   */\n  constructor(prm) {\n    try {\n      super(prm, 'rem');\n      this.modname('Rem');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toPixel() {\n    try {\n      /* get html font-size */\n      let h_fsiz = document.documentElement.style[\"fontSize\"];\n      if (\"\" === h_fsiz) {\n        h_fsiz = 625; // default size\n      } else {\n        h_fsiz = parseFloat(h_fsiz);\n      }\n      /* get body font-size */\n      let b_fsiz = document.body.style[\"fontSize\"];\n      if (\"\" === b_fsiz) {\n        b_fsiz = \"0.16\"; // default size\n      } else {\n        b_fsiz = parseFloat(b_fsiz);\n      }\n      return this.value() * (b_fsiz * h_fsiz);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  calcu(prm, flg) {\n    try {\n      super.calcu(prm, flg);\n      if ('px' === this.type()) {\n        this.value(this.px2Rem());\n        this.type('rem');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Rem.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Size.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Size.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Size.js\n * @brief size data type\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\n/**\n * @class Size\n * @brief Size Defined Class\n */\nmodule.exports = class extends Base {\n  /**\n   *\n   */\n  constructor(siz, tp) {\n    try {\n      super();\n      this.modname('Size');\n      this.confmng().add(\"type\", {\n        type: \"string\",\n        init: \"\"\n      });\n      this.confmng().add(\"value\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"option\", {\n        type: \"object\",\n        init: {}\n      });\n      if ('number' === typeof siz && 'string' === typeof tp) {\n        this.value(siz);\n        this.type(tp);\n      } else {\n        throw new Error(\"invalid parameter\");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  option(prm) {\n    try {\n      return this.confmng(\"option\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toStyle() {\n    try {\n      return [this.toString(), this.option()];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toString() {\n    try {\n      return null === this.type() ? null : this.value() + this.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  toPixel() {\n    try {\n      throw new Error(\"not supported\");\n    } catch (e) {\n      throw e;\n    }\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Size.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/common.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/common.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file common.js\n * @brief common util functions\n */\n\nmofron.util.common = {\n  isinc: (obj, nm) => {\n    try {\n      /* parameter check */\n      if (null === obj || 'object' !== typeof obj || true === Array.isArray(obj) || \"function\" !== typeof obj.modname || \"function\" !== typeof obj.confmng) {\n        return false;\n      }\n      let chk_nm = \"string\" === typeof nm ? [nm] : nm;\n      let chk_idx = 0;\n      let name_lst = obj.confmng(\"modname\");\n      for (let idx in name_lst) {\n        if (chk_nm[chk_idx] === name_lst[idx]) {\n          chk_idx++;\n          if (chk_nm.length === chk_idx) {\n            return true;\n          }\n          continue;\n        }\n        if (0 < chk_idx) {\n          break;\n        }\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  iscmp: obj => {\n    try {\n      return comutl.isinc(obj, \"Component\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isobj: (obj, nm) => {\n    try {\n      return obj.modname() === nm ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcmp: prm => {\n    try {\n      return new mofron.class.Component(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcolor: prm => {\n    try {\n      if (null === prm || undefined === prm) {\n        return null;\n      } else if ('string' === typeof prm) {\n        if ('none' === prm) {\n          return new mofron.class.Color();\n        } else if (0 === prm.indexOf('rgb')) {\n          let rgb_clr = null;\n          if (0 === prm.indexOf('rgba(')) {\n            rgb_clr = prm.substring(5);\n          } else if (0 === prm.indexOf('rgb(')) {\n            rgb_clr = prm.substring(4);\n          } else {\n            throw new Error('invalid parameter');\n          }\n          rgb_clr = rgb_clr.substring(0, rgb_clr.length - 1);\n          rgb_clr = rgb_clr.split(',');\n          if (3 === rgb_clr.length) {\n            return new mofron.class.Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2])]);\n          } else if (4 === rgb_clr.length) {\n            return new mofron.class.Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2]), parseInt(rgb_clr[3])]);\n          } else {\n            throw new Error('invalid parameter');\n          }\n        } else if (0 === prm.indexOf('#')) {\n          /* hex */\n          let hex_clr = prm.substring(1);\n          if (6 !== hex_clr.length) {\n            throw new Error('invalid parameter');\n          }\n          return new mofron.class.Color([parseInt(hex_clr.substring(0, 2), 16), parseInt(hex_clr.substring(2, 4), 16), parseInt(hex_clr.substring(4, 6), 16)]);\n        } else {\n          /* name */\n          if ('string' !== typeof prm) {\n            throw new Error('invalid parameter');\n          }\n          switch (prm) {\n            case 'black':\n              return new mofron.class.Color([0, 0, 0]);\n            case 'gray':\n              return new mofron.class.Color([128, 128, 128]);\n            case 'silver':\n              return new mofron.class.Color([192, 192, 192]);\n            case 'white':\n              return new mofron.class.Color([255, 255, 255]);\n            case 'blue':\n              return new mofron.class.Color([0, 0, 255]);\n            case 'navy':\n              return new mofron.class.Color([0, 0, 128]);\n            case 'teal':\n              return new mofron.class.Color([0, 128, 128]);\n            case 'green':\n              return new mofron.class.Color([0, 128, 0]);\n            case 'lime':\n              return new mofron.class.Color([0, 255, 0]);\n            case 'aqua':\n              return new mofron.class.Color([0, 255, 255]);\n            case 'yellow':\n              return new mofron.class.Color([255, 255, 0]);\n            case 'red':\n              return new mofron.class.Color([255, 0, 0]);\n            case 'fuchsia':\n              return new mofron.class.Color([255, 0, 255]);\n            case 'olive':\n              return new mofron.class.Color([128, 128, 0]);\n            case 'purple':\n              return new mofron.class.Color([128, 0, 128]);\n            case 'maroon':\n              return new mofron.class.Color([128, 0, 0]);\n            default:\n              throw new Error('not supported color');\n          }\n        }\n      } else if (true === Array.isArray(prm)) {\n        return new mofron.class.Color(prm);\n      } else if (true === comutl.isinc(prm, 'Color')) {\n        return prm;\n      } else {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getsize: prm => {\n    try {\n      let siz = null;\n      /* parameter check */\n      if ('string' !== typeof prm) {\n        if (null === prm || undefined === prm) {\n          return null;\n        } else if (true === comutl.isinc(prm, \"Size\")) {\n          return prm;\n        } else {\n          throw new Error('invalid parameter');\n        }\n      }\n      /* get size type */\n      let stype = ['px', '%', 'rem', 'em', 'vw', 'vh'];\n      let ptype = null;\n      for (let sidx in stype) {\n        if (2 !== prm.split(stype[sidx]).length) {\n          continue;\n        }\n        ptype = stype[sidx];\n        break;\n      }\n      if (null === ptype) {\n        throw new Error('not supported size type');\n      }\n      /* get value */\n      let sval = null;\n      sp_prm = prm.split(ptype);\n      if (2 === sp_prm[0].split('.').length) {\n        sval = parseFloat(sp_prm[0]);\n      } else {\n        sval = parseInt(sp_prm[0]);\n      }\n      if ('px' === ptype) {\n        return new mofron.class.Pixel(sval);\n      } else if ('rem' === ptype) {\n        return new mofron.class.Rem(sval);\n      } else {\n        return new mofron.class.Size(sval, ptype);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizetype: prm => {\n    try {\n      let size = comutl.getsize(prm);\n      return null === size ? null : size.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizesum: (p1, p2) => {\n    try {\n      let prm1 = 'string' === typeof p1 ? comutl.getsize(p1) : p1;\n      let prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n      if (null == prm1 && true === comutl.isinc(prm2, ['Base', 'Size'])) {\n        return prm2.toString();\n      } else if (null == prm2 && true === comutl.isinc(prm1, ['Base', 'Size'])) {\n        return prm1.toString();\n      } else if (null === prm1 && null === prm2) {\n        return null;\n      }\n      if (true !== comutl.isinc(prm1, ['Base', 'Size']) || true !== comutl.isinc(prm2, ['Base', 'Size'])) {\n        throw new Error('invalid parameter');\n      }\n      if (prm1.type() !== prm2.type()) {\n        if (undefined === prm1.toPixel() || undefined === prm2.toPixel()) {\n          throw new Error('not supported type');\n        }\n        return new mofron.class.Pixel(prm1.toPixel() + prm2.toPixel()).toString();\n      } else {\n        let val_1 = comutl.roundup(prm1.value());\n        let val_2 = comutl.roundup(prm2.value());\n        return comutl.roundup(val_1 + val_2) + prm1.type();\n      }\n    } catch (e) {\n      throw e;\n    }\n  },\n  sizediff: (p1, p2) => {\n    try {\n      let prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n      if (true !== comutl.isinc(prm2, \"Size\")) {\n        throw new Error('not supported type');\n      }\n      let prm2_buf = comutl.getsize(prm2.toString());\n      prm2_buf.value(prm2_buf.value() * -1);\n      return comutl.sizesum(p1, prm2_buf);\n    } catch (e) {\n      throw e;\n    }\n  },\n  roundup: prm => {\n    try {\n      let flo = comutl.flo2int(prm);\n      if (1000 >= flo[1]) {\n        return prm;\n      }\n      return Math.floor(flo[0] / flo[1] * 1000) / 1000;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  flo2int: prm => {\n    try {\n      if ('number' !== typeof prm) {\n        throw new Error('invalid parameter');\n      }\n      let chk = null;\n      let pos = 0;\n      let wei = 1;\n      chk = prm + '';\n      pos = chk.indexOf('.');\n      if (-1 === pos) {\n        return [prm, 1];\n      }\n      for (pos = chk.length - 1 - pos; 0 < pos; pos--) {\n        wei = wei * 10;\n      }\n      return [prm * wei, wei];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  chkacc: opt => {\n    try {\n      for (let oidx in opt) {\n        if (\"device\" !== oidx && \"os\" !== oidx && \"browser\" !== oidx && \"orientation\" !== oidx) {\n          console.warn(\"unknown index:\" + oidx);\n          return false;\n        }\n        if (\"device\" === oidx) {\n          if (true === Array.isArray(opt[oidx])) {\n            let dev_chk = false;\n            for (let didx in opt[oidx]) {\n              if (opt[oidx][didx] === comutl.accdev()) {\n                dev_chk = true;\n              }\n            }\n            if (false === dev_chk) {\n              return false;\n            }\n          } else {\n            if (opt[oidx] !== comutl.accdev()) {\n              return false;\n            }\n          }\n        } else if (\"os\" === oidx) {\n          if (opt[oidx] !== comutl.accos()) {\n            return false;\n          }\n        } else if (\"browser\" === oidx) {\n          if (opt[oidx] !== comutl.accbrs()) {\n            return false;\n          }\n        } else if (\"orientation\" === oidx) {\n          let ochk = \"portrait\" === opt.orientation ? true : false;\n          if (ochk !== mofron.window.isPortrait()) {\n            return false;\n          }\n        }\n      }\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accdev: () => {\n    try {\n      let ua = window.navigator.userAgent;\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('Android') > 0 && ua.indexOf('Mobile') > 0) {\n        return 'mobile';\n      } else if (ua.indexOf('iPad') > 0 || ua.indexOf('Android') > 0) {\n        return 'tablet';\n      } else {\n        return 'default';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accos: () => {\n    try {\n      let ua = window.navigator.userAgent;\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('iPad') > 0) {\n        return 'ios';\n      } else if (ua.indexOf('Android') > 0) {\n        return 'android';\n      } else if (ua.indexOf('Windows') > 0) {\n        return 'windows';\n      } else if (ua.indexOf('Mac OS') > 0) {\n        return 'mac';\n      } else if (ua.indexOf('Linux') > 0) {\n        return 'linux';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accbrs: () => {\n    try {\n      let ua = window.navigator.userAgent.toLowerCase();\n      if (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1) {\n        return 'ie';\n      } else if (ua.indexOf('edge') != -1) {\n        return 'edge';\n      } else if (ua.indexOf('chrome') != -1) {\n        return 'chrome';\n      } else if (ua.indexOf('safari') != -1) {\n        return 'safari';\n      } else if (ua.indexOf('firefox') != -1) {\n        return 'firefox';\n      } else if (ua.indexOf('opera') != -1) {\n        return 'opera';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addhead: (tag, atr, txt) => {\n    try {\n      let conts = \"<\" + tag + \" \";\n      /* set attributes */\n      for (let aidx in atr) {\n        conts += aidx + '=' + atr[aidx] + ' ';\n      }\n      conts = conts.substring(0, conts.length - 1) + \">\";\n      if ('link' !== tag && 'meta' !== tag && 'base' !== tag) {\n        /* set contents */\n        conts += txt + \"</\" + tag + \">\";\n      }\n      if (undefined !== mofron.ssr) {\n        mofron.ssr.head(conts);\n      } else {\n        document.head.insertAdjacentHTML('beforeend', conts);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addstyle: (id, prm, append) => {\n    try {\n      let style = document.getElementById(id);\n      if (null === style) {\n        comutl.addhead(\"style\", {\n          id: id\n        }, prm);\n      } else if (false !== append) {\n        style.innerText += prm;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  obj2style: (sel, cnt) => {\n    try {\n      let ret = sel + \" {\";\n      for (let cidx in cnt) {\n        ret += cidx + \":\" + cnt[cidx] + \";\";\n      }\n      return ret + \"}\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst comutl = mofron.util.common;\nmodule.exports = mofron.util.common;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/common.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/component.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/util/component.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file component.js\n * @brief util functions for component\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmofron.util.component = {\n  chdloop: (cmp, key, prm) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      let chd = cmp.getTree().getChild();\n      let argc = false === Array.isArray(prm) ? 0 : prm.length;\n      for (let cidx in chd) {\n        if (0 === argc) {\n          chd[cidx][key]();\n        } else if (1 === argc) {\n          chd[cidx][key](p1);\n        } else if (2 === argc) {\n          chd[cidx][key](p1, p2);\n        } else if (3 === argc) {\n          chd[cidx][key](p1, p2, p3);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  ischild: (pnt, cmp) => {\n    try {\n      let ret = false;\n      let pchd = pnt.getTree().child();\n      for (let cidx in pchd) {\n        if (true === comutl.ischild(chd[cidx], cmp)) {\n          return true;\n        } else if (chd[cidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isinncmp: cmp => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      let chd_cmp = cmp.childDom().component();\n      if (null === chd_cmp || null === chd_cmp.getTree().parent()) {\n        return false;\n      }\n      let pnt_buf = chd_cmp.getTree().parent();\n      while (null !== pnt_buf) {\n        if (cmp.id() === pnt_buf.id()) {\n          /* target is inner component */\n          return true;\n        }\n        pnt_buf = pnt_buf.getTree().parent();\n      }\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  modconf: (cmp, idx, po, opt) => {\n    try {\n      if (true === Array.isArray(po)) {\n        for (let pidx in po) {\n          cmputl.modconf(cmp, idx, po[pidx], opt);\n        }\n        return;\n      }\n      if (false === comutl.isinc(po, \"ModConf\")) {\n        /* getter */\n        let mc_lst = cmp.confmng().get(idx);\n        if ('object' !== typeof po) {\n          return mc_lst;\n        }\n        let ret = [];\n        let hit = null;\n        for (let mc_idx in mc_lst) {\n          hit = true;\n          for (let pidx in po) {\n            if (mc_lst[mc_idx][pidx]() !== po[pidx]) {\n              hit = false;\n              break;\n            }\n          }\n          if (true === hit) {\n            ret.push(mc_lst[mc_idx]);\n          }\n        }\n        if (0 === ret.length) {\n          return null;\n        } else {\n          return 1 === ret.length ? ret[0] : ret;\n        }\n      }\n      /* setter */\n      po.component(cmp);\n      cmp.confmng(idx, po, opt);\n      if (true === cmp.isExists() && \"effect\" !== idx) {\n        po.execute();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initmconf: (cmp, idx) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      let chd = cmp.getTree().getChild();\n      for (let cidx in chd) {\n        cmputl.initmconf(chd[cidx], idx);\n      }\n      /* init module config */\n      if (-1 !== idx.indexOf('effect')) {\n        cmputl.initeffect(cmp, idx);\n      } else {\n        let cnf = cmputl.modconf(cmp, idx);\n        for (let cfidx in cnf) {\n          cnf[cfidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initeffect: (cmp, idx) => {\n    try {\n      let eid = \"none\" !== cmp.style(\"display\") ? 0 : 1;\n      let exe_lst = [];\n      if (\"zsp_effect\" === idx) {\n        exe_lst = cmp.effect({\n          speed: 0\n        });\n        if (null === exe_lst) {\n          return;\n        } else if (false === Array.isArray(exe_lst)) {\n          exe_lst = [exe_lst];\n        }\n      } else {\n        let eff_lst = [];\n        eff_lst = cmp.effect({\n          eid: -1\n        });\n        if (null === eff_lst) {\n          eff_lst = [];\n        } else if (false === Array.isArray(eff_lst)) {\n          eff_lst = [eff_lst];\n        }\n        if (null !== cmp.effect({\n          eid: eid\n        })) {\n          eff_lst = eff_lst.concat(cmp.effect({\n            eid: eid\n          }));\n        }\n        for (let eidx in eff_lst) {\n          if (0 !== eff_lst[eidx].speed()) {\n            exe_lst.push(eff_lst[eidx]);\n          }\n        }\n      }\n      if (0 === exe_lst.length) {\n        return;\n      }\n      mofron.util.effect.exec(exe_lst, -1);\n      mofron.util.effect.exec(exe_lst, eid);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  follow_theme: cmp => {\n    try {\n      let ret = {};\n      let chk_cmp = cmp.parent();\n      let chk_thm = null;\n      while (chk_cmp) {\n        chk_thm = chk_cmp.theme();\n        for (tidx in chk_thm) {\n          if (!ret[tidx]) {\n            ret[tidx] = chk_thm[tidx];\n          }\n        }\n        chk_cmp = chk_cmp.parent();\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  theme: (cmp, thm) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      /*\n       * create the theme for execution with theme of component\n       * added to theme of parameter.\n       */\n      let exe_thm = {};\n      for (let thm_idx in thm) {\n        exe_thm[thm_idx] = thm[thm_idx];\n      }\n      let cmp_thm = cmp.theme();\n      for (let cmp_idx in cmp_thm) {\n        exe_thm[cmp_idx] = cmp_thm[cmp_idx];\n      }\n\n      /* check ignore */\n      let is_ign = false;\n      let exe_thm2 = {};\n      for (let e_idx in exe_thm) {\n        is_ign = false;\n        if (undefined !== exe_thm[e_idx].ignore) {\n          if (true === Array.isArray(exe_thm[e_idx].ignore)) {\n            for (let e_idx2 in exe_thm[e_idx].ignore) {\n              if (cmp.name() === exe_thm[e_idx].ignore[e_idx2]) {\n                is_ign = true;\n              }\n            }\n          } else if (cmp.name() === exe_thm[e_idx].ignore) {\n            is_ign = true;\n          }\n        }\n        if (false === is_ign) {\n          exe_thm2[e_idx] = exe_thm[e_idx];\n        }\n      }\n      let chd = cmp.getTree().getChild();\n      let inn_cmp = cmp.confmng(\"innerComp\");\n      /* theme core process */\n      for (let thm_tgt in exe_thm2) {\n        if (true === comutl.isinc(cmp, thm_tgt)) {\n          if (undefined !== exe_thm2[thm_tgt].replace) {\n            if (true === comutl.isobj(cmp, thm_tgt)) {\n              /* replace component */\n              let rep_cmp = new exe_thm2[thm_tgt].replace();\n              if (undefined !== exe_thm2[thm_tgt].config) {\n                rep_cmp.config(exe_thm2[thm_tgt].config);\n              }\n              rep_cmp.config(cmp.config());\n              cmp.parent().getTree().replace(cmp, rep_cmp);\n              /* update child list for execution theme */\n              chd = rep_cmp.getTree().getChild();\n              for (let inn_idx2 in inn_cmp) {\n                rep_cmp[inn_idx2]().config(inn_cmp[inn_idx2].config());\n              }\n            }\n          } else if (undefined !== exe_thm2[thm_tgt].config) {\n            /* config theme */\n            for (let cnf_idx in exe_thm2[thm_tgt].config) {\n              if ('layout' === cnf_idx || 'effect' === cnf_idx || 'event' === cnf_idx) {\n                for (let cnf_idx_2 in exe_thm2[thm_tgt].config[cnf_idx]) {\n                  let cnf_nm = exe_thm2[thm_tgt].config[cnf_idx][cnf_idx_2].modname();\n                  let rep_cnf = new mofron.require[cnf_nm]();\n                  rep_cnf.config(exe_thm2[thm_tgt].config[cnf_idx][cnf_idx_2].config());\n                  exe_thm2[thm_tgt].config[cnf_idx][cnf_idx_2] = rep_cnf;\n                }\n              }\n            }\n            cmp.config(exe_thm2[thm_tgt].config);\n          }\n        }\n        for (let inn_idx in inn_cmp) {\n          if (true === comutl.isobj(inn_cmp[inn_idx], thm_tgt) && undefined !== exe_thm2[thm_tgt].replace) {\n            let rep_inn = new exe_thm2[thm_tgt].replace();\n            if (undefined !== exe_thm2[thm_tgt].config) {\n              rep_inn.config(exe_thm2[thm_tgt].config);\n            }\n            rep_inn.config(inn_cmp[inn_idx].config());\n            inn_cmp[inn_idx].parent().getTree().replace(inn_cmp[inn_idx], rep_inn);\n            inn_cmp[inn_idx] = rep_inn;\n            break;\n          }\n        }\n      }\n\n      /* execute child theme */\n      for (let cidx in chd) {\n        let buf_thm = {};\n        for (let eth_idx in exe_thm2) {\n          buf_thm[eth_idx] = exe_thm2[eth_idx];\n        }\n        mofron.util.component.theme(chd[cidx], buf_thm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  size: (cmp, key, val, opt) => {\n    try {\n      /* setter */\n      if (false === comutl.iscmp(cmp) || \"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n      let style_val = {};\n      if (null === comutl.getsize(val)) {\n        style_val[key] = null;\n      } else {\n        style_val[key] = comutl.getsize(val).toString();\n      }\n      cmp.config({\n        style: new mofron.class.ConfArg(style_val, opt)\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  color: (cmp, key, val, opt) => {\n    try {\n      if (false === comutl.iscmp(cmp) || \"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n      let style_val = {};\n      style_val[key] = null === val ? null : comutl.getcolor(val).toString();\n      if (undefined === opt) {\n        opt = {\n          private: true\n        };\n      } else {\n        opt.private = true;\n      }\n      cmp.style(style_val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  display: (cmp, flg) => {\n    try {\n      /* check parameter */\n      if (false === comutl.iscmp(cmp) || 'boolean' !== typeof flg) {\n        throw new Error('invalid parameter');\n      }\n      let buf = null;\n      let rdom = cmp.rootDom();\n      for (let ridx in rdom) {\n        if (true === flg) {\n          /* diplayed target dom, set display value from buffer */\n          if ('none' === rdom[ridx].style(\"display\") && true === rdom[ridx].isPushed()) {\n            buf = cmputl.dispbuff(rdom[ridx]);\n            rdom[ridx].style({\n              \"display\": undefined === buf ? null : buf\n            });\n            cmputl.dispbuff(rdom[ridx], null);\n          }\n        } else {\n          /* hidden target dom, buffering display value */\n          buf = rdom[ridx].style(\"display\");\n          if ('none' !== buf && null !== buf) {\n            cmputl.dispbuff(rdom[ridx], buf);\n          }\n          rdom[ridx].style({\n            \"display\": \"none\"\n          });\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  dispbuff: (dom, val) => {\n    try {\n      if (false === comutl.isinc(dom, \"Dom\")) {\n        throw new Error(\"invalid parameter\");\n      }\n      let dkey = dom.id() + \"_display\";\n      if (undefined === val) {\n        /* getter */\n        return dom.data(dkey);\n      }\n      /* setter */\n      dom.data(dkey, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  exec_effect: (cmp, eid, cb) => {\n    try {\n      let chd = cmp.child();\n      for (let cidx in chd) {\n        mofron.util.component.exec_effect(chd[cidx], eid);\n      }\n      if (false === cmp.execEffect(eid, cb)) {\n        if ('function' === typeof cb) {\n          cb();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  visible: (cmp, vflg, ef, ep) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      if (undefined === vflg) {\n        /* getter */\n        if (false === cmp.isExists()) {\n          /* it does not rendered yet */\n          return false;\n        }\n        let doms = cmp.rootDom();\n        for (let didx in doms) {\n          if ('none' !== doms[didx].style('display')) {\n            return true;\n          }\n        }\n        return false;\n      }\n      /* setter */\n      if ('boolean' !== typeof vflg) {\n        throw new Error('invalid parameter');\n      }\n      if (false === cmp.isExists()) {\n        /* render component */\n        cmputl.display(cmp, vflg);\n        if (true === vflg) {\n          cmputl.render(cmp, ef, ep);\n        }\n        return;\n      } else if (true === vflg) {\n        cmputl.display(cmp, vflg);\n      }\n      let scb = () => {\n        try {\n          if (false === vflg) {\n            cmputl.display(cmp, false);\n          }\n          if (\"function\" === typeof ef) {\n            ef(cmp, cmp.visible(), ep);\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n      cmputl.exec_effect(cmp, true === vflg ? 0 : 1, scb);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  render: (cmp, cbf, cbp) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      /* execute theme */\n      cmputl.theme(cmp, {});\n\n      /* execute layout modules */\n      cmputl.initmconf(cmp, \"layout\");\n\n      /* before push event */\n      cmp.beforeRender();\n\n      /* execute effect module that is 0 speed */\n      cmputl.initmconf(cmp, \"zsp_effect\");\n\n      /* render */\n      let rdom = cmp.rootDom();\n      for (let ridx in rdom) {\n        if (null === rdom[ridx].parent()) {\n          rdom[ridx].push({\n            target: document.body\n          });\n        } else {\n          let cmp_idx = cmp.parent().getTree().getIndex(cmp);\n          let pc_len = cmp.parent().child().length;\n          if (cmp_idx === pc_len - 1) {\n            /* insert to last of parent */\n            rdom[ridx].push({\n              target: rdom[ridx].parent().getRawDom()\n            });\n          } else {\n            /* insert to target index of parent */\n            rdom[ridx].push({\n              target: cmp.parent().child()[cmp_idx + 1].rootDom()[0].getRawDom(),\n              position: 'beforebegin'\n            });\n          }\n        }\n      }\n      /* after push event */\n      cmp.afterRender();\n      if (\"function\" === typeof cbf) {\n        cbf(cmp, cmp.visible(), cbp);\n      }\n\n      /* execute effect modules */\n      cmputl.initmconf(cmp, \"effect\");\n\n      /* execute event modules */\n      cmputl.initmconf(cmp, \"event\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  rstyle: (cmp, sty, opt) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      let root = cmp.rootDom();\n      for (let ridx in root) {\n        root[ridx].style(sty, opt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst cmputl = mofron.util.component;\nmodule.exports = mofron.util.component;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/component.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/effect.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/effect.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file effect.js\n */\nconst cmputl = mofron.util.component;\nmofron.util.effect = {\n  exec: (eff, eid, evf, oid) => {\n    try {\n      let _oid = undefined === oid ? 0 : oid;\n      let elst = effutl.getlist(eff, eid, _oid);\n      if (0 === elst.length) {\n        return false;\n      }\n\n      /* execute before event */\n      for (let eidx in elst) {\n        let b_evt = elst[eidx].beforeEvent();\n        for (let bidx in b_evt) {\n          b_evt[bidx][0](elst[eidx], elst[eidx].component(), b_evt[bidx][1]);\n        }\n      }\n      /* set transition */\n      effutl.transition(elst);\n      let next_order = () => {\n        let fin_cnt = 0;\n        return (p1, p2, p3) => {\n          try {\n            let eff_cmp = elst[fin_cnt].component();\n            fin_cnt++;\n            if (p3 <= fin_cnt) {\n              if (false === effutl.exec(eff, eid, evf, oid + 1)) {\n                /* release transition */\n                cmputl.rstyle(eff_cmp, {\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                eff_cmp.styleDom().style({\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                /* execute callback function */\n                if (undefined !== evf && \"function\" === typeof evf[0]) {\n                  evf[0](p2, eid, evf[1]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n      };\n      let next = next_order(eff, eid, evf, oid);\n      for (let eidx2 in elst) {\n        elst[eidx2].otCallback(next, elst.length);\n        setTimeout(tm => {\n          tm.execute();\n        }, 0 === elst[eidx2].speed() ? 0 : 50, elst[eidx2]);\n      }\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  /**\n   * get valid list from effect lists\n   */\n  getlist: (eff, eid, oid) => {\n    try {\n      let elst = [];\n      for (let eidx in eff) {\n        if (true === eff[eidx].isSkipped(eid, oid)) {\n          continue;\n        }\n        elst.push(eff[eidx]);\n      }\n      return elst;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initlist: cmp => {\n    try {\n      let ret = [];\n      let chd = cmp.child();\n      for (let cidx in chd) {\n        let chd_ret = effutl.initlist(chd[cidx]);\n        if (null !== chd_ret) {\n          for (let cidx in chd_ret) {\n            ret.push(chd_ret[cidx]);\n          }\n        }\n      }\n      let eff = cmputl.modconf(cmp, \"effect\");\n      let oid = 0;\n      let buf = null;\n      while (true) {\n        buf = effutl.getlist(eff, true === cmp.visible() ? 0 : 1, oid);\n        if (0 === buf.length) {\n          break;\n        }\n        for (let bidx in buf) {\n          ret.push(buf[bidx]);\n        }\n        oid++;\n      }\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  transition: eff => {\n    try {\n      let rdom = eff[0].component().rootDom();\n      let cmp_trans = {}; //effutl.gettrans(rdom.style('tarnsition'));\n\n      /* get the effect transition that will be executed */\n      let eff_trans = {};\n      for (let eidx in eff) {\n        if (0 === eff[eidx].speed()) {\n          continue;\n        }\n        let tbuf = eff[eidx].transition();\n        for (let bidx in tbuf) {\n          eff_trans[tbuf[bidx]] = eff[eidx].speed() + 'ms ';\n          if (null === eff[eidx].cubicBezier()) {\n            eff_trans[tbuf[bidx]] += eff[eidx].timing();\n          } else {\n            let cubic = eff[eidx].cubicBezier();\n            eff_trans[tbuf[bidx]] += 'cubic-bezier(' + cubic[0] + ',' + cubic[1] + ',' + cubic[2] + ',' + cubic[3] + ')';\n          }\n          eff_trans[tbuf[bidx]] += ' ' + eff[eidx].delay() + 'ms';\n        }\n      }\n      if (0 === Object.keys(eff_trans).length) {\n        return;\n      }\n      /* set transition list to buff */\n      for (let tidx in eff_trans) {\n        cmp_trans[tidx] = eff_trans[tidx];\n      }\n      let setval = {\n        'transition': \"\"\n      };\n      for (let tidx2 in cmp_trans) {\n        setval.transition += tidx2 + \" \" + cmp_trans[tidx2] + \",\";\n      }\n      if (0 < setval.transition.length) {\n        setval.transition = setval.transition.substring(0, setval.transition.length - 1);\n      }\n      cmputl.rstyle(eff[0].component(), setval, {\n        bpref: true\n      });\n      eff[0].component().styleDom().style(setval, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getfirst: (eff, eid, ord) => {\n    try {\n      for (let eidx in eff) {\n        if (false === eff[eidx].isSkipped(eid, ord)) {\n          return parseInt(eidx);\n        }\n      }\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getlast: (eff, eid, ord) => {\n    try {\n      let tgt_lst = [];\n      for (let eidx in eff) {\n        if (eid !== eff[eidx].eid()) {\n          continue;\n        } else if ('number' === typeof ord && ord !== eff[eidx].order()) {\n          continue;\n        }\n        tgt_lst.push(eff[eidx]);\n      }\n      if (0 === tgt_lst.length) {\n        return null;\n      }\n      let last = tgt_lst[tgt_lst.length - 1];\n      for (let eidx2 in eff) {\n        if (eff[eidx2].id() === last.id()) {\n          return parseInt(eidx2);\n        }\n      }\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  setconf: (cmp, einf, cnf) => {\n    try {\n      let eff = cmp.effect(einf);\n      if (null === eff) {\n        throw new Error(\"invalid parameter\");\n      }\n      eff = true !== Array.isArray(eff) ? [eff] : eff;\n      for (let eidx in eff) {\n        eff[eidx].config(cnf);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst effutl = mofron.util.effect;\nmodule.exports = mofron.util.effect;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/effect.js?");

/***/ }),

/***/ "./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!../../../babel-loader/lib/index.js??ruleSet[1].rules[0].use!./namesp.js */ \"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../../../expose-loader/dist/runtime/getGlobalThis.js */ \"./node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"mofron\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"mofron\"] = ___EXPOSE_LOADER_IMPORT___;\nelse throw new Error('[exposes-loader] The \"mofron\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option')\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp-exposed.js?./node_modules/expose-loader/dist/cjs.js?exposes=mofron");

/***/ }),

/***/ "./node_modules/mofron/index.js":
/*!**************************************!*\
  !*** ./node_modules/mofron/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! expose-loader?exposes=mofron!./src/core/namesp.js */ \"./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js\");\n\n/* util functions */\n__webpack_require__(/*! ./src/util/common.js */ \"./node_modules/mofron/src/util/common.js\");\n__webpack_require__(/*! ./src/util/component.js */ \"./node_modules/mofron/src/util/component.js\");\n__webpack_require__(/*! ./src/util/effect.js */ \"./node_modules/mofron/src/util/effect.js\");\n\nmofron.class.ConfArg  = __webpack_require__(/*! ./src/type/ConfArg.js */ \"./node_modules/mofron/src/type/ConfArg.js\");\nmofron.class.PullConf = __webpack_require__(/*! ./src/type/PullConf.js */ \"./node_modules/mofron/src/type/PullConf.js\");\n\nmofron.class.Dom       = __webpack_require__(/*! ./src/core/dom/Dom.js */ \"./node_modules/mofron/src/core/dom/Dom.js\");\nmofron.class.Component = __webpack_require__(/*! ./src/tag/Component.js */ \"./node_modules/mofron/src/tag/Component.js\");\nmofron.class.Layout    = __webpack_require__(/*! ./src/tag/Layout.js */ \"./node_modules/mofron/src/tag/Layout.js\");\nmofron.class.Effect    = __webpack_require__(/*! ./src/tag/Effect.js */ \"./node_modules/mofron/src/tag/Effect.js\");\nmofron.class.Event     = __webpack_require__(/*! ./src/tag/Event.js */ \"./node_modules/mofron/src/tag/Event.js\");\nmofron.class.Color     = __webpack_require__(/*! ./src/type/Color.js */ \"./node_modules/mofron/src/type/Color.js\");\nmofron.class.Size      = __webpack_require__(/*! ./src/type/size/Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\nmofron.class.Pixel     = __webpack_require__(/*! ./src/type/size/Pixel.js */ \"./node_modules/mofron/src/type/size/Pixel.js\");\nmofron.class.Rem       = __webpack_require__(/*! ./src/type/size/Rem.js */ \"./node_modules/mofron/src/type/size/Rem.js\");\n\nlet Window = __webpack_require__(/*! ./src/core/Window.js */ \"./node_modules/mofron/src/core/Window.js\");\nmofron.window = new Window();\nlet Document = __webpack_require__(/*! ./src/core/Document.js */ \"./node_modules/mofron/src/core/Document.js\");\nmofron.document = new Document();\n\nmodule.exports = mofron;\n\n\n//# sourceURL=webpack:///./node_modules/mofron/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/index.js");
/******/ 	
/******/ })()
;